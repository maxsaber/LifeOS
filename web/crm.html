<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>LifeOS CRM</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --text-muted: #6a6a8a;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --border: #2a2a4e;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
            --people: #00bcd4;
            --people-hover: #26c6da;
            --sidebar-width: 320px;
            --header-height: 56px;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            padding-top: var(--safe-top);
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-left h1 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1rem;
            padding: 0.375rem 0.5rem;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .header-brand:hover {
            background: var(--bg-tertiary);
        }

        .header-nav {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin-left: 0.5rem;
            padding-left: 0.75rem;
            border-left: 1px solid var(--border);
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-link.active {
            background: var(--accent);
            color: white;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .stats-display {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .stat-item .value {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Main layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left panel - People list */
        .people-list-panel {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .search-bar {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--people);
        }

        .search-input::placeholder {
            color: var(--text-muted);
        }

        .filters {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-chip:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .filter-chip.active {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .people-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .person-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 0.25rem;
        }

        .person-card:hover {
            background: var(--bg-tertiary);
        }

        .person-card.selected {
            background: var(--bg-tertiary);
            border: 1px solid var(--people);
        }

        .person-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--people) 0%, var(--people-hover) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .person-company {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .person-strength {
            width: 32px;
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }

        .person-strength-bar {
            height: 100%;
            background: var(--people);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .dunbar-badge {
            font-size: 0.625rem;
            font-weight: 600;
            min-width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: var(--bg-primary);
            color: var(--text-secondary);
            margin-left: 0.5rem;
        }

        .dunbar-badge.circle-0 { background: #e94560; color: white; }
        .dunbar-badge.circle-1 { background: #ff6b6b; color: white; }
        .dunbar-badge.circle-2 { background: #ffa502; color: white; }
        .dunbar-badge.circle-3 { background: #2ed573; color: white; }
        .dunbar-badge.circle-4 { background: #1e90ff; color: white; }
        .dunbar-badge.circle-5 { background: #5352ed; color: white; }
        .dunbar-badge.circle-6 { background: #747d8c; color: white; }

        .source-badges {
            display: flex;
            gap: 0.25rem;
        }

        .source-badge {
            font-size: 0.625rem;
            padding: 0.125rem 0.25rem;
            background: var(--bg-primary);
            border-radius: 4px;
        }

        /* Multi-select checkbox */
        .person-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border);
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .person-checkbox:hover {
            border-color: var(--people);
        }

        .person-checkbox.checked {
            background: var(--people);
            border-color: var(--people);
        }

        .person-checkbox.checked::after {
            content: 'âœ“';
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
        }

        /* Merge toolbar */
        .merge-toolbar {
            display: none;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .merge-toolbar.visible {
            display: flex;
        }

        .merge-toolbar-info {
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .merge-toolbar-info strong {
            color: var(--people);
        }

        .merge-toolbar-actions {
            display: flex;
            gap: 0.5rem;
        }

        .merge-btn {
            padding: 0.5rem 1rem;
            background: var(--people);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .merge-btn:hover {
            background: var(--people-hover);
        }

        .clear-selection-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .clear-selection-btn:hover {
            border-color: var(--text-secondary);
            color: var(--text-primary);
        }

        /* Split modal */
        .split-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .split-modal.visible {
            display: flex;
        }

        .split-modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .split-modal-header {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .split-modal-section {
            margin-bottom: 1rem;
        }

        .split-modal-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .split-source-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .split-source-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
        }

        .split-source-item:last-child {
            border-bottom: none;
        }

        .split-source-item:hover {
            background: var(--bg-tertiary);
        }

        .split-source-item.selected {
            background: rgba(0, 188, 212, 0.1);
        }

        .split-source-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .split-source-badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .split-source-info {
            flex: 1;
            min-width: 0;
        }

        .split-source-name {
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .split-source-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .split-target-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .split-target-options {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .split-target-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .split-target-option:hover {
            background: var(--bg-tertiary);
        }

        .split-target-option.selected {
            background: rgba(0, 188, 212, 0.1);
        }

        .split-person-search {
            margin-top: 0.5rem;
            padding: 0.5rem;
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .split-person-results {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .split-person-result {
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .split-person-result:hover {
            background: var(--bg-tertiary);
        }

        .split-person-result.selected {
            background: rgba(0, 188, 212, 0.2);
        }

        .split-new-name-input {
            margin-top: 0.5rem;
            padding: 0.5rem;
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .split-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .split-cancel-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
        }

        .split-confirm-btn {
            padding: 0.5rem 1rem;
            background: var(--people);
            border: none;
            border-radius: 6px;
            color: var(--bg-primary);
            font-weight: 600;
            cursor: pointer;
        }

        .split-confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .split-btn {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .split-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Merge modal */
        .merge-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .merge-modal.visible {
            display: flex;
        }

        .merge-modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .merge-modal-header {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .merge-modal-section {
            margin-bottom: 1.5rem;
        }

        .merge-modal-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .merge-primary-select {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .merge-person-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .merge-person-option:hover {
            border-color: var(--border);
        }

        .merge-person-option.selected {
            border-color: var(--people);
            background: rgba(0, 188, 212, 0.1);
        }

        .merge-person-option .person-avatar {
            width: 32px;
            height: 32px;
            font-size: 0.75rem;
        }

        .merge-person-details {
            flex: 1;
        }

        .merge-person-name {
            font-weight: 500;
            font-size: 0.875rem;
        }

        .merge-person-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .merge-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .merge-cancel-btn {
            padding: 0.625rem 1.25rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        .merge-confirm-btn {
            padding: 0.625rem 1.25rem;
            background: var(--people);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
        }

        .merge-confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Right panel - Person detail */
        .detail-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-primary);
        }

        .detail-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            color: var(--text-muted);
        }

        .detail-empty-icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        .detail-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        /* Compact header for graph mode */
        .graph-mode .detail-header {
            padding: 0.75rem 1.5rem;
            align-items: center;
        }

        .graph-mode .detail-avatar {
            width: 40px;
            height: 40px;
            font-size: 1rem;
        }

        .graph-mode .detail-company,
        .graph-mode .detail-contact-quick,
        .graph-mode .detail-tags,
        .graph-mode .detail-actions {
            display: none;
        }

        .graph-mode .detail-name {
            font-size: 1.1rem;
            margin-bottom: 0;
        }

        .graph-mode .detail-content {
            padding: 0.5rem;
        }

        .graph-mode #tabGraph {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .detail-avatar {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--people) 0%, var(--people-hover) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }

        .detail-title {
            flex: 1;
        }

        .detail-name {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .detail-company {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .detail-contact-quick {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .detail-contact-link {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .detail-contact-link:hover {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .detail-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            margin-top: 0.5rem;
        }

        .detail-tag-chip {
            padding: 0.25rem 0.625rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }

        .detail-tag-chip .remove-tag {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.875rem;
            line-height: 1;
        }

        .detail-tag-chip .remove-tag:hover {
            color: var(--error);
        }

        .detail-tag-add {
            padding: 0.25rem 0.625rem;
            background: transparent;
            border: 1px dashed var(--border);
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }

        .detail-tag-add:hover {
            border-color: var(--people);
            color: var(--people);
        }

        .detail-actions {
            display: flex;
            gap: 0.5rem;
        }

        .detail-strength-container {
            text-align: right;
        }

        .detail-strength-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .detail-strength-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--people);
        }

        /* Tabs */
        .detail-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            padding: 0 1rem;
        }

        .tab {
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--people);
            border-bottom-color: var(--people);
        }

        .detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }

        /* Overview tab */
        .info-section {
            margin-bottom: 1.5rem;
        }

        .info-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.75rem;
        }

        /* Relationship strength breakdown */
        .strength-breakdown {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .strength-bar-main {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .strength-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--people) 0%, var(--people-hover) 100%);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .strength-components {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
        }

        .strength-component {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .strength-component-icon {
            font-size: 1rem;
        }

        .strength-component-info {
            flex: 1;
            min-width: 0;
        }

        .strength-component-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .strength-component-value {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Hero Stats Row - Compact inline stats */
        .hero-stats {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1rem;
            background: linear-gradient(135deg, rgba(22, 33, 62, 0.6) 0%, rgba(15, 52, 96, 0.4) 100%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .hero-stat {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.3rem 0.625rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            font-size: 0.8125rem;
            transition: all 0.2s ease;
            cursor: default;
        }

        .hero-stat:hover {
            background: rgba(0, 188, 212, 0.15);
        }

        .hero-stat-icon {
            font-size: 0.8125rem;
            opacity: 0.9;
        }

        .hero-stat-value {
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
            font-weight: 600;
            color: var(--people);
        }

        .hero-stat-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .hero-stat-divider {
            width: 1px;
            height: 18px;
            background: var(--border);
            margin: 0 0.125rem;
        }

        /* Strength ring in hero stats */
        .hero-strength {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            padding-left: 0.5rem;
        }

        .strength-ring {
            position: relative;
            width: 32px;
            height: 32px;
        }

        .strength-ring svg {
            transform: rotate(-90deg);
        }

        .strength-ring-bg {
            fill: none;
            stroke: var(--bg-tertiary);
            stroke-width: 3;
        }

        .strength-ring-fill {
            fill: none;
            stroke: var(--people);
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .strength-ring-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
            font-size: 0.5625rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .hero-strength-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Dunbar circle in hero stats */
        .hero-dunbar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-left: 0.75rem;
            border-left: 1px solid var(--border);
            margin-left: 0.5rem;
        }

        .dunbar-circle-indicator {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .dunbar-circle-indicator.circle-0 { background: #e94560; }
        .dunbar-circle-indicator.circle-1 { background: #ff6b6b; }
        .dunbar-circle-indicator.circle-2 { background: #ffa502; }
        .dunbar-circle-indicator.circle-3 { background: #2ed573; }
        .dunbar-circle-indicator.circle-4 { background: #1e90ff; }
        .dunbar-circle-indicator.circle-5 { background: #5352ed; }
        .dunbar-circle-indicator.circle-6 { background: #747d8c; }

        .hero-dunbar-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Legacy stats cards - hidden by default, kept for backwards compatibility */
        .stats-cards {
            display: none;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: all 0.2s;
        }

        .stat-card:hover {
            background: var(--bg-tertiary);
            transform: translateY(-2px);
        }

        .stat-card-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .stat-card-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--people);
            margin-bottom: 0.25rem;
        }

        .stat-card-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Heat map calendar - GitHub contribution style */
        .heatmap-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            overflow-x: auto;
        }

        .heatmap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .heatmap-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.625rem;
            color: var(--text-muted);
        }

        .heatmap-legend-item {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .heatmap-scroll-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
        }

        .heatmap-inner {
            min-width: fit-content;
        }

        .heatmap-months {
            display: flex;
            margin-bottom: 4px;
            font-size: 0.625rem;
            color: var(--text-muted);
            padding-left: 28px; /* Aligns with grid (weekday labels width + margin) */
            gap: 2px; /* Match the grid gap */
        }

        .heatmap-month-label {
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            /* Width set dynamically via JS to match week columns */
        }

        .heatmap-body {
            display: flex;
            gap: 2px;
        }

        .heatmap-weekdays {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-right: 4px;
            font-size: 0.5625rem;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .heatmap-weekday {
            height: 10px;
            line-height: 10px;
            width: 24px;
            text-align: right;
        }

        .heatmap-weekday:nth-child(even) {
            visibility: hidden;
        }

        .heatmap-grid {
            display: flex;
            gap: 2px;
            flex: 1;
        }

        .heatmap-week {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .heatmap-day {
            width: 10px;
            height: 10px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .heatmap-day:hover {
            transform: scale(1.3);
            z-index: 10;
        }

        .heatmap-day[data-level="0"] { background: var(--bg-tertiary); }
        .heatmap-day[data-level="1"] { background: rgba(0, 188, 212, 0.25); }
        .heatmap-day[data-level="2"] { background: rgba(0, 188, 212, 0.45); }
        .heatmap-day[data-level="3"] { background: rgba(0, 188, 212, 0.65); }
        .heatmap-day[data-level="4"] { background: rgba(0, 188, 212, 0.85); }
        .heatmap-day[data-level="5"] { background: var(--people); }

        /* Floating tooltip */
        .heatmap-tooltip {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            font-size: 0.75rem;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.15s;
        }

        .heatmap-tooltip.visible {
            opacity: 1;
        }

        .heatmap-tooltip-date {
            font-weight: 600;
            margin-bottom: 0.375rem;
            color: var(--text-primary);
        }

        .heatmap-tooltip-item {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            margin-bottom: 0.125rem;
            color: var(--text-secondary);
        }

        .heatmap-tooltip-total {
            margin-top: 0.375rem;
            padding-top: 0.375rem;
            border-top: 1px solid var(--border);
            font-weight: 600;
            color: var(--people);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.75rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .info-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .info-value {
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .info-value a {
            color: var(--people);
            text-decoration: none;
        }

        .info-value a:hover {
            text-decoration: underline;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tag {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .notes-area {
            width: 100%;
            min-height: 100px;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.875rem;
            resize: vertical;
        }

        .notes-area:focus {
            outline: none;
            border-color: var(--people);
        }

        /* Two-column content grid for Overview tab */
        .overview-content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 900px) {
            .overview-content-grid {
                grid-template-columns: 1fr;
            }
        }

        .overview-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
        }

        .overview-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .overview-panel-title {
            font-size: 0.6875rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Contact info compact styling */
        .contact-grid-compact {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .contact-row {
            display: flex;
            align-items: flex-start;
            gap: 0.625rem;
        }

        .contact-icon-box {
            flex-shrink: 0;
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.75rem;
        }

        .contact-values {
            flex: 1;
            min-width: 0;
        }

        .contact-value-link {
            font-size: 0.8125rem;
            color: var(--people);
            text-decoration: none;
            display: block;
            padding: 0.0625rem 0;
            transition: color 0.2s;
            word-break: break-all;
        }

        .contact-value-link:hover {
            color: var(--people-hover);
        }

        .contact-meta-row {
            display: flex;
            gap: 1.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .contact-meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }

        .contact-meta-label {
            font-size: 0.5625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .contact-meta-value {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        /* Notes panel collapsed state */
        .notes-panel-compact {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
        }

        .notes-panel-compact .notes-area {
            min-height: 70px;
            margin-top: 0.5rem;
            background: rgba(0, 0, 0, 0.15);
        }

        /* Source entities footer (collapsed by default) */
        .source-entities-footer {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .source-entities-toggle-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.625rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .source-entities-toggle-bar:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .source-entities-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .source-entities-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .source-entities-count-badge {
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
            font-size: 0.6875rem;
            color: var(--text-secondary);
            padding: 0.125rem 0.375rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .source-entities-chevron {
            color: var(--text-muted);
            font-size: 0.5rem;
            transition: transform 0.2s;
        }

        .source-entities-footer.expanded .source-entities-chevron {
            transform: rotate(180deg);
        }

        .source-entities-expanded-content {
            display: none;
            padding: 0 1rem 1rem;
        }

        .source-entities-footer.expanded .source-entities-expanded-content {
            display: block;
        }

        /* Timeline tab */
        .timeline-filters {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .timeline-filter-chip {
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-filter-chip:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .timeline-filter-chip.active {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .timeline-date-filter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.625rem 0.875rem;
            background: rgba(0, 188, 212, 0.1);
            border: 1px solid rgba(0, 188, 212, 0.3);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            font-size: 0.8125rem;
            color: var(--people);
        }

        .timeline-date-filter button {
            background: transparent;
            border: 1px solid var(--people);
            color: var(--people);
            padding: 0.25rem 0.625rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .timeline-date-filter button:hover {
            background: var(--people);
            color: white;
        }

        .timeline-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .timeline-item:hover {
            background: var(--bg-tertiary);
            border-color: var(--people);
        }

        .timeline-badge {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            flex-shrink: 0;
        }

        .timeline-content {
            flex: 1;
            min-width: 0;
        }

        .timeline-title {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-title a {
            color: var(--text-primary);
            text-decoration: none;
        }

        .timeline-title a:hover {
            color: var(--people);
            text-decoration: underline;
        }

        .timeline-snippet {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .timeline-source-badge {
            display: inline-block;
            padding: 0.125rem 0.375rem;
            background: var(--bg-primary);
            border-radius: 4px;
            font-size: 0.625rem;
            margin-left: 0.5rem;
        }

        /* Graph visualization */
        .graph-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .graph-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .graph-btn:hover {
            background: var(--people);
        }

        .graph-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .graph-toggle input {
            cursor: pointer;
        }

        .graph-slider-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-left: 1rem;
        }

        .graph-slider-container input[type="range"] {
            width: 120px;
            cursor: pointer;
            accent-color: var(--people);
        }

        .graph-slider-container span {
            min-width: 35px;
            color: var(--text-primary);
        }

        .graph-degree-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-left: 1rem;
        }

        .graph-degree-toggle select {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        .graph-degree-toggle select:focus {
            outline: none;
            border-color: var(--people);
        }

        .graph-source-filter {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-left: 1rem;
            position: relative;
        }

        .source-filter-dropdown {
            position: relative;
        }

        .source-filter-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        .source-filter-btn:hover {
            border-color: var(--people);
        }

        .dropdown-arrow {
            font-size: 0.6rem;
            color: var(--text-secondary);
        }

        .source-filter-options {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.25rem;
            z-index: 200;
            min-width: 160px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .source-filter-options.visible {
            display: block;
        }

        .source-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.3rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .source-option:hover {
            background: var(--bg-secondary);
        }

        .source-option input {
            cursor: pointer;
        }

        .source-icon {
            font-size: 0.9rem;
        }

        .edge-panel-section-title {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            border-top: 1px solid var(--border);
            padding-top: 0.5rem;
        }

        .graph-wrapper {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .graph-container {
            width: 100%;
            flex: 1;
            min-height: 400px;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .graph-container svg {
            width: 100%;
            height: 100%;
        }

        .graph-node {
            cursor: pointer;
        }

        .graph-node circle {
            stroke: var(--bg-primary);
            stroke-width: 2px;
            transition: r 0.2s;
        }

        .graph-node:hover circle {
            stroke: var(--people);
            stroke-width: 3px;
        }

        .graph-node.selected circle {
            stroke: var(--accent);
            stroke-width: 3px;
        }

        .graph-node text {
            fill: var(--text-primary);
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
        }

        /* Degree-based node styling */
        .graph-node.degree-0 text {
            font-size: 12px;
            font-weight: 600;
        }

        .graph-node.degree-2 text {
            font-size: 9px;
            fill: var(--text-secondary);
        }

        .graph-link {
            /* Base styles - actual stroke/opacity set dynamically based on weight */
            stroke-linecap: round;
            cursor: pointer;
            transition: stroke-width 0.15s, stroke-opacity 0.15s, stroke 0.15s;
        }

        .graph-link:hover {
            stroke-opacity: 1 !important;
            stroke-width: 4px !important;
        }

        .graph-link.selected {
            stroke: #ff6b6b !important;
            stroke-opacity: 1 !important;
            stroke-width: 4px !important;
        }

        .graph-tooltip {
            position: absolute;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            color: var(--text-primary);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .graph-tooltip.visible {
            opacity: 1;
        }

        .edge-panel {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 280px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 101;
            display: none;
        }

        .edge-panel.visible {
            display: block;
        }

        .edge-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .edge-panel-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .edge-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            line-height: 1;
        }

        .edge-panel-close:hover {
            color: var(--text-primary);
        }

        .edge-panel-people {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }

        .edge-panel-person {
            color: var(--people);
            cursor: pointer;
        }

        .edge-panel-person:hover {
            text-decoration: underline;
        }

        .edge-panel-connector {
            color: var(--text-secondary);
        }

        .edge-panel-stat {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
        }

        .edge-panel-stat:last-child {
            border-bottom: none;
        }

        .edge-panel-stat-label {
            color: var(--text-secondary);
        }

        .edge-panel-stat-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .edge-panel-contexts {
            margin-top: 0.75rem;
        }

        .edge-panel-contexts-title {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }

        .edge-panel-context-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .edge-panel-context-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .graph-legend {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            background: rgba(26, 26, 46, 0.9);
            border-radius: 6px;
            padding: 0.5rem;
            font-size: 0.75rem;
        }

        .graph-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .graph-legend-item:last-child {
            margin-bottom: 0;
        }

        .graph-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Source entities section */
        .source-entities-section {
            border-top: 1px solid var(--border);
            margin-top: 1rem;
            padding-top: 1rem;
        }

        .source-entities-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .source-entities-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .source-entities-toggle {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .source-entities-list {
            display: none;
        }

        .source-entities-list.expanded {
            display: block;
        }

        .source-entity-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            font-size: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-bottom: 0.25rem;
        }

        .source-entity-badge {
            font-size: 0.875rem;
        }

        .source-entity-info {
            flex: 1;
            min-width: 0;
        }

        .source-entity-name {
            color: var(--text-primary);
        }

        .source-entity-meta {
            color: var(--text-muted);
        }

        .source-entity-status {
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            font-size: 0.625rem;
            text-transform: uppercase;
        }

        .source-entity-status.confirmed {
            background: var(--success);
            color: white;
        }

        .source-entity-status.auto {
            background: var(--warning);
            color: white;
        }

        /* Button styles */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--people);
            color: white;
        }

        .btn-primary:hover {
            background: var(--people-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-primary);
        }

        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: var(--text-muted);
        }

        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top-color: var(--people);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 0.5rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-muted);
            text-align: center;
        }

        .empty-state-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        /* Quick Facts section */
        .quick-facts-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .quick-facts-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .quick-facts-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .extract-facts-btn {
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .extract-facts-btn:hover {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .extract-facts-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .extract-facts-btn.extracting::after {
            content: '';
            width: 12px;
            height: 12px;
            border: 2px solid var(--border);
            border-top-color: var(--people);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .facts-categories {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .facts-category {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .facts-category-header {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .facts-category-icon {
            font-size: 0.875rem;
        }

        .facts-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .fact-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.375rem 0;
            font-size: 0.8rem;
            color: var(--text-primary);
            position: relative;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .fact-item:hover {
            background: var(--bg-tertiary);
        }

        .fact-item.unconfirmed {
            opacity: 0.85;
        }

        .fact-item.unconfirmed::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 4px;
            background: var(--warning);
            border-radius: 50%;
        }

        .fact-bullet {
            color: var(--text-muted);
            flex-shrink: 0;
            margin-top: 0.1rem;
        }

        .fact-content {
            flex: 1;
            min-width: 0;
        }

        .fact-text {
            color: var(--text-primary);
            line-height: 1.4;
        }

        .fact-source {
            color: var(--text-muted);
            font-size: 0.7rem;
            margin-left: 0.25rem;
            cursor: help;
            position: relative;
        }

        .fact-source:hover {
            color: var(--people);
        }

        .fact-source-tooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .fact-source:hover .fact-source-tooltip {
            display: block;
        }

        .fact-actions {
            display: none;
            gap: 0.25rem;
            flex-shrink: 0;
        }

        .fact-item:hover .fact-actions {
            display: flex;
        }

        .fact-action-btn {
            background: none;
            border: none;
            padding: 0.125rem;
            cursor: pointer;
            font-size: 0.7rem;
            color: var(--text-muted);
            opacity: 0.6;
            transition: opacity 0.15s, color 0.15s;
        }

        .fact-action-btn:hover {
            opacity: 1;
        }

        .fact-action-btn.confirm:hover {
            color: var(--success);
        }

        .fact-action-btn.delete:hover {
            color: var(--error);
        }

        .facts-empty {
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 0.5rem 0;
        }

        /* Fact source quote - shown on hover */
        .fact-quote {
            display: none;
            margin-top: 0.375rem;
            padding: 0.5rem;
            background: var(--bg-primary);
            border-left: 2px solid var(--people);
            border-radius: 0 4px 4px 0;
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-style: italic;
            line-height: 1.4;
        }

        .fact-item:hover .fact-quote {
            display: block;
        }

        .fact-quote::before {
            content: '"';
            color: var(--people);
            font-size: 0.875rem;
        }

        .fact-quote::after {
            content: '"';
            color: var(--people);
            font-size: 0.875rem;
        }

        /* Clickable source link */
        .fact-source-link {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            color: var(--people);
            text-decoration: none;
            font-size: 0.65rem;
            padding: 0.125rem 0.375rem;
            background: rgba(0, 188, 212, 0.1);
            border-radius: 3px;
            transition: all 0.15s;
            margin-left: 0.375rem;
        }

        .fact-source-link:hover {
            background: rgba(0, 188, 212, 0.2);
            color: var(--people-hover);
        }

        .fact-source-link-icon {
            font-size: 0.625rem;
        }

        /* Confidence indicator */
        .fact-confidence {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.625rem;
            color: var(--text-muted);
        }

        .fact-confidence-bar {
            width: 30px;
            height: 3px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }

        .fact-confidence-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }

        .fact-confidence-fill.high {
            background: var(--success);
        }

        .fact-confidence-fill.medium {
            background: var(--warning);
        }

        .fact-confidence-fill.low {
            background: var(--error);
        }

        /* Summary facts have distinct styling */
        .facts-category.summary .fact-item {
            background: linear-gradient(90deg, rgba(0, 188, 212, 0.05) 0%, transparent 100%);
            padding: 0.5rem;
            margin: 0.25rem 0;
        }

        .facts-category.summary .fact-text {
            font-size: 0.75rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .people-list-panel {
                width: 100%;
                height: 50%;
            }

            .detail-panel {
                height: 50%;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <a href="/" class="header-brand">LifeOS</a>
            <nav class="header-nav">
                <a href="/chat" class="nav-link">ðŸ’¬ Chat</a>
                <a href="/crm" class="nav-link active">ðŸ‘¥ CRM</a>
            </nav>
        </div>
        <div class="header-right">
            <div class="stats-display">
                <div class="stat-item">
                    <span>People:</span>
                    <span class="value" id="totalPeople">-</span>
                </div>
            </div>
        </div>
    </header>

    <div class="main-container">
        <div class="people-list-panel">
            <div class="search-bar">
                <input type="text" class="search-input" id="searchInput" placeholder="Search people..." oninput="handleSearch()">
            </div>
            <div class="filters">
                <div class="filter-chip active" data-filter="all" onclick="setFilter('all')">All</div>
                <div class="filter-chip" data-filter="work" onclick="setFilter('work')">Work</div>
                <div class="filter-chip" data-filter="personal" onclick="setFilter('personal')">Personal</div>
                <div class="filter-chip" data-filter="family" onclick="setFilter('family')">Family</div>
            </div>
            <div class="merge-toolbar" id="mergeToolbar">
                <div class="merge-toolbar-info">
                    <strong id="selectedCount">0</strong> people selected
                </div>
                <div class="merge-toolbar-actions">
                    <button class="clear-selection-btn" onclick="clearSelection()">Clear</button>
                    <button class="merge-btn" onclick="openMergeModal()">Merge Selected</button>
                </div>
            </div>
            <div class="people-list" id="peopleList">
                <div class="loading">Loading people...</div>
            </div>
        </div>

        <div class="detail-panel" id="detailPanel">
            <div class="detail-empty" id="detailEmpty">
                <div class="detail-empty-icon">ðŸ‘¤</div>
                <p>Select a person to view details</p>
            </div>
            <div id="detailContent" style="display:none">
                <div class="detail-header">
                    <div class="detail-avatar" id="detailAvatar">JD</div>
                    <div class="detail-title">
                        <div class="detail-name" id="detailName">John Doe</div>
                        <div class="detail-company" id="detailCompany">Acme Corp Â· Software Engineer</div>
                        <div class="detail-contact-quick" id="detailContactQuick"></div>
                        <div class="detail-tags" id="detailTagsChips"></div>
                    </div>
                </div>

                <div class="detail-tabs">
                    <div class="tab active" data-tab="overview" onclick="switchTab('overview')">Overview</div>
                    <div class="tab" data-tab="timeline" onclick="switchTab('timeline')">Timeline</div>
                    <div class="tab" data-tab="graph" onclick="switchTab('graph')">Graph</div>
                </div>

                <div class="detail-content">
                    <div id="tabOverview" class="tab-content">
                        <!-- Hero Stats Row -->
                        <div class="hero-stats" id="heroStats">
                            <div class="hero-stat">
                                <span class="hero-stat-icon">ðŸ“§</span>
                                <span class="hero-stat-value" id="heroStatEmails">0</span>
                                <span class="hero-stat-label">emails</span>
                            </div>
                            <div class="hero-stat">
                                <span class="hero-stat-icon">ðŸ“…</span>
                                <span class="hero-stat-value" id="heroStatEvents">0</span>
                                <span class="hero-stat-label">events</span>
                            </div>
                            <div class="hero-stat">
                                <span class="hero-stat-icon">ðŸ’¬</span>
                                <span class="hero-stat-value" id="heroStatMessages">0</span>
                                <span class="hero-stat-label">messages</span>
                            </div>
                            <div class="hero-stat-divider"></div>
                            <div class="hero-stat">
                                <span class="hero-stat-icon">ðŸ“</span>
                                <span class="hero-stat-label">Since</span>
                                <span class="hero-stat-value" id="heroStatFirstSeen">â€”</span>
                            </div>
                            <div class="hero-strength">
                                <div class="strength-ring">
                                    <svg width="32" height="32" viewBox="0 0 32 32">
                                        <circle class="strength-ring-bg" cx="16" cy="16" r="13"/>
                                        <circle class="strength-ring-fill" id="strengthRingFill" cx="16" cy="16" r="13"
                                                stroke-dasharray="81.68" stroke-dashoffset="81.68"/>
                                    </svg>
                                    <span class="strength-ring-value" id="strengthRingValue">0</span>
                                </div>
                                <span class="hero-strength-label">Strength</span>
                            </div>
                            <div class="hero-dunbar">
                                <div class="dunbar-circle-indicator" id="dunbarCircleIndicator">0</div>
                                <span class="hero-dunbar-label" id="dunbarCircleLabel">Intimate</span>
                            </div>
                        </div>

                        <!-- Heat map calendar -->
                        <div class="heatmap-container">
                            <div class="heatmap-header">
                                <div class="heatmap-title">365-Day Interaction History</div>
                                <div class="heatmap-legend">
                                    <span>Less</span>
                                    <div class="heatmap-legend-item" style="background: var(--bg-tertiary)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.25)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.45)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.65)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.85)"></div>
                                    <div class="heatmap-legend-item" style="background: var(--people)"></div>
                                    <span>More</span>
                                </div>
                            </div>
                            <div class="heatmap-scroll-wrapper">
                                <div class="heatmap-inner">
                                    <div class="heatmap-months" id="heatmapMonths"></div>
                                    <div class="heatmap-body">
                                        <div class="heatmap-weekdays">
                                            <div class="heatmap-weekday">Sun</div>
                                            <div class="heatmap-weekday">Mon</div>
                                            <div class="heatmap-weekday">Tue</div>
                                            <div class="heatmap-weekday">Wed</div>
                                            <div class="heatmap-weekday">Thu</div>
                                            <div class="heatmap-weekday">Fri</div>
                                            <div class="heatmap-weekday">Sat</div>
                                        </div>
                                        <div class="heatmap-grid" id="heatmapGrid"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="heatmap-tooltip" id="heatmapTooltip"></div>

                        <!-- Two-column content grid -->
                        <div class="overview-content-grid">
                            <!-- Quick Facts - Left Column -->
                            <div class="quick-facts-section overview-panel">
                                <div class="overview-panel-header">
                                    <span class="overview-panel-title">Quick Facts</span>
                                    <button class="extract-facts-btn" id="extractFactsBtn" onclick="extractFacts()">
                                        <span>Extract Facts</span>
                                    </button>
                                </div>
                                <div class="facts-categories" id="factsContainer">
                                    <div class="facts-empty">No facts extracted yet. Click "Extract Facts" to analyze interactions.</div>
                                </div>
                            </div>

                            <!-- Contact & Notes - Right Column -->
                            <div style="display: flex; flex-direction: column; gap: 1rem;">
                                <!-- Contact Info -->
                                <div class="overview-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Contact</span>
                                    </div>
                                    <div class="contact-grid-compact" id="contactInfoCompact"></div>
                                </div>

                                <!-- Notes -->
                                <div class="notes-panel-compact">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Notes</span>
                                    </div>
                                    <textarea class="notes-area" id="notesArea" placeholder="Add notes about this person..." onchange="saveNotes()"></textarea>
                                </div>
                            </div>
                        </div>

                        <!-- Source entities footer (collapsed) -->
                        <div class="source-entities-footer" id="sourceEntitiesFooter">
                            <div class="source-entities-toggle-bar" onclick="toggleSourceEntities()">
                                <div class="source-entities-info">
                                    <span class="source-entities-label">Source Entities</span>
                                    <span class="source-entities-count-badge" id="sourceEntitiesCount">0</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.75rem;">
                                    <button class="split-btn" onclick="event.stopPropagation(); openSplitModal()">Split Sources</button>
                                    <span class="source-entities-chevron" id="sourceEntitiesToggle">â–¼</span>
                                </div>
                            </div>
                            <div class="source-entities-expanded-content">
                                <div class="source-entities-list" id="sourceEntitiesList"></div>
                            </div>
                        </div>

                        <!-- Hidden elements for backwards compatibility -->
                        <div style="display:none">
                            <div id="strengthBarFill"></div>
                            <div id="strengthComponents"></div>
                            <div id="contactInfo"></div>
                            <div id="statEmails"></div>
                            <div id="statMeetings"></div>
                            <div id="statMessages"></div>
                            <div id="statNotes"></div>
                        </div>
                    </div>

                    <div id="tabTimeline" class="tab-content" style="display:none">
                        <div class="timeline-filters">
                            <div class="timeline-filter-chip active" data-source="all" onclick="filterTimeline('all')">All</div>
                            <div class="timeline-filter-chip" data-source="email" onclick="filterTimeline('email')">ðŸ“§ Email</div>
                            <div class="timeline-filter-chip" data-source="calendar" onclick="filterTimeline('calendar')">ðŸ“… Calendar</div>
                            <div class="timeline-filter-chip" data-source="drive" onclick="filterTimeline('drive')">ðŸ“„ Drive</div>
                            <div class="timeline-filter-chip" data-source="message" onclick="filterTimeline('message')">ðŸ’¬ Message</div>
                        </div>
                        <div class="timeline" id="timelineContainer">
                            <div class="loading">Loading timeline...</div>
                        </div>
                    </div>

                    <div id="tabGraph" class="tab-content" style="display:none">
                        <div class="graph-controls">
                            <button class="graph-btn" onclick="resetGraphZoom()">Reset Zoom</button>
                            <label class="graph-toggle">
                                <input type="checkbox" id="showLabels" checked onchange="toggleGraphLabels()">
                                Show Labels
                            </label>
                            <div class="graph-slider-container">
                                <label for="edgeStrengthSlider">Edge Weight:</label>
                                <input type="range" id="edgeStrengthSlider" min="0" max="100" value="50" oninput="updateEdgeVisibility(this.value)">
                                <span id="edgeStrengthValue">50%</span>
                            </div>
                            <div class="graph-degree-toggle">
                                <label>Show:</label>
                                <select id="degreeFilter" onchange="updateDegreeFilter(this.value)">
                                    <option value="all">1st & 2nd Degree</option>
                                    <option value="first" selected>1st Degree Only</option>
                                </select>
                            </div>
                            <div class="graph-source-filter">
                                <label>Sources:</label>
                                <div class="source-filter-dropdown" id="sourceFilterDropdown">
                                    <button class="source-filter-btn" onclick="toggleSourceFilter()">
                                        <span id="sourceFilterLabel">All Sources</span>
                                        <span class="dropdown-arrow">â–¼</span>
                                    </button>
                                    <div class="source-filter-options" id="sourceFilterOptions">
                                        <label class="source-option">
                                            <input type="checkbox" value="calendar" checked onchange="updateSourceFilter()">
                                            <span class="source-icon">ðŸ“…</span> Calendar
                                        </label>
                                        <label class="source-option">
                                            <input type="checkbox" value="email" checked onchange="updateSourceFilter()">
                                            <span class="source-icon">ðŸ“§</span> Email
                                        </label>
                                        <label class="source-option">
                                            <input type="checkbox" value="imessage" checked onchange="updateSourceFilter()">
                                            <span class="source-icon">ðŸ’¬</span> iMessage
                                        </label>
                                        <label class="source-option">
                                            <input type="checkbox" value="whatsapp" checked onchange="updateSourceFilter()">
                                            <span class="source-icon">ðŸ“±</span> WhatsApp
                                        </label>
                                        <label class="source-option">
                                            <input type="checkbox" value="slack" checked onchange="updateSourceFilter()">
                                            <span class="source-icon">ðŸ’¼</span> Slack
                                        </label>
                                        <label class="source-option">
                                            <input type="checkbox" value="phone" checked onchange="updateSourceFilter()">
                                            <span class="source-icon">ðŸ“ž</span> Phone
                                        </label>
                                        <label class="source-option">
                                            <input type="checkbox" value="linkedin" checked onchange="updateSourceFilter()">
                                            <span class="source-icon">ðŸ”—</span> LinkedIn
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="graph-wrapper">
                            <div id="graphContainer" class="graph-container">
                                <div class="loading">Loading graph...</div>
                            </div>
                            <div id="edgePanel" class="edge-panel">
                                <div class="edge-panel-header">
                                    <div class="edge-panel-title">Connection Details</div>
                                    <button class="edge-panel-close" onclick="closeEdgePanel()">&times;</button>
                                </div>
                                <div class="edge-panel-people">
                                    <span class="edge-panel-person" id="edgePanelPersonA" onclick="navigateToEdgePerson('a')">Person A</span>
                                    <span class="edge-panel-connector">&harr;</span>
                                    <span class="edge-panel-person" id="edgePanelPersonB" onclick="navigateToEdgePerson('b')">Person B</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">Edge Weight</span>
                                    <span class="edge-panel-stat-value" id="edgePanelWeight">0</span>
                                </div>
                                <div class="edge-panel-section-title">Source Breakdown</div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“… Calendar Events</span>
                                    <span class="edge-panel-stat-value" id="edgePanelEvents">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“§ Email Threads</span>
                                    <span class="edge-panel-stat-value" id="edgePanelThreads">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ’¬ iMessage</span>
                                    <span class="edge-panel-stat-value" id="edgePanelMessages">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“± WhatsApp</span>
                                    <span class="edge-panel-stat-value" id="edgePanelWhatsapp">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ’¼ Slack DMs</span>
                                    <span class="edge-panel-stat-value" id="edgePanelSlack">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“ž Phone Calls</span>
                                    <span class="edge-panel-stat-value" id="edgePanelPhone">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ”— LinkedIn</span>
                                    <span class="edge-panel-stat-value" id="edgePanelLinkedin">â€”</span>
                                </div>
                                <div class="edge-panel-section-title">Timing</div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">First Seen Together</span>
                                    <span class="edge-panel-stat-value" id="edgePanelFirstSeen">â€”</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">Last Seen Together</span>
                                    <span class="edge-panel-stat-value" id="edgePanelLastSeen">â€”</span>
                                </div>
                                <div class="edge-panel-contexts" id="edgePanelContexts">
                                    <div class="edge-panel-contexts-title">Shared Contexts</div>
                                    <div class="edge-panel-context-tags" id="edgePanelContextTags"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Merge Modal -->
    <div class="merge-modal" id="mergeModal">
        <div class="merge-modal-content">
            <div class="merge-modal-header">Merge People</div>
            <div class="merge-modal-section">
                <div class="merge-modal-label">Select the primary record (this person will be kept):</div>
                <div class="merge-primary-select" id="mergePrimarySelect"></div>
            </div>
            <div class="merge-modal-section">
                <div class="merge-modal-label">The following will be merged into the primary:</div>
                <ul id="mergeSecondaryList" style="color: var(--text-secondary); font-size: 0.875rem; padding-left: 1.25rem;"></ul>
            </div>
            <div class="merge-modal-actions">
                <button class="merge-cancel-btn" onclick="closeMergeModal()">Cancel</button>
                <button class="merge-confirm-btn" id="mergeConfirmBtn" onclick="confirmMerge()" disabled>Merge</button>
            </div>
        </div>
    </div>

    <!-- Split Modal -->
    <div class="split-modal" id="splitModal">
        <div class="split-modal-content">
            <div class="split-modal-header">Split Sources</div>
            <div class="split-modal-section">
                <div class="split-modal-label">
                    Select sources that don't belong to <strong id="splitFromPersonName"></strong>:
                </div>
                <div class="split-source-list" id="splitSourceList">
                    <div class="loading">Loading sources...</div>
                </div>
            </div>
            <div class="split-target-section">
                <div class="split-modal-label">Move selected sources to:</div>
                <div class="split-target-options">
                    <label class="split-target-option" onclick="setSplitTarget('existing')">
                        <input type="radio" name="splitTarget" value="existing">
                        Existing person
                    </label>
                    <div id="splitExistingSection" style="display: none; margin-left: 1.5rem;">
                        <input type="text" class="split-person-search" id="splitPersonSearch"
                               placeholder="Search for person..." oninput="searchSplitTarget()">
                        <div class="split-person-results" id="splitPersonResults"></div>
                    </div>
                    <label class="split-target-option" onclick="setSplitTarget('new')">
                        <input type="radio" name="splitTarget" value="new">
                        Create new person
                    </label>
                    <div id="splitNewSection" style="display: none; margin-left: 1.5rem;">
                        <input type="text" class="split-new-name-input" id="splitNewPersonName"
                               placeholder="Enter new person's name...">
                    </div>
                </div>
            </div>
            <div class="split-modal-section" style="margin-top: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="splitCreateOverrides" checked>
                    <span style="font-size: 0.875rem;">Create disambiguation rules to prevent future mis-linking</span>
                </label>
            </div>
            <div class="split-modal-actions">
                <button class="split-cancel-btn" onclick="closeSplitModal()">Cancel</button>
                <button class="split-confirm-btn" id="splitConfirmBtn" onclick="confirmSplit()" disabled>
                    Split <span id="splitCount">0</span> Sources
                </button>
            </div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // State
        let people = [];
        let selectedPersonId = null;
        let currentFilter = 'all';
        let searchQuery = '';
        let selectedForMerge = new Set();  // IDs selected for merge
        let mergePrimaryId = null;  // Primary person for merge
        let dunbarCircleMap = new Map();  // Map person ID to Dunbar circle

        // Dunbar Circle Configuration
        // Circle sizes: 0=3 (manual), 1=5, 2=15, 3=50, 4=150, 5=500, 6=1500, 7+=rest
        const DUNBAR_CONFIG = {
            myPersonId: '3f41e143-719f-4dc9-a9f1-389b2db5b166',
            manualCircleZero: ['Taylor Walker', 'Malea Ramia'],  // Always in circle 0
            // Cumulative thresholds (excluding circle 0 manual entries and self)
            thresholds: [0, 5, 20, 70, 220, 720, 2220]  // Circle 1-6 boundaries
        };

        // Compute Dunbar circle for each person based on relationship strength rank
        function assignDunbarCircles(peopleList) {
            // Sort by relationship strength descending
            const sorted = [...peopleList].sort((a, b) =>
                (b.relationship_strength || 0) - (a.relationship_strength || 0)
            );

            // Create a map for quick lookup
            const circleMap = new Map();

            // Assign circle 0 to self and manual entries
            circleMap.set(DUNBAR_CONFIG.myPersonId, 0);
            sorted.forEach(p => {
                if (DUNBAR_CONFIG.manualCircleZero.includes(p.canonical_name)) {
                    circleMap.set(p.id, 0);
                }
            });

            // Assign circles to remaining people based on rank
            let rank = 0;
            for (const person of sorted) {
                if (circleMap.has(person.id)) continue;  // Skip already assigned

                // Find which circle this rank falls into
                let circle = DUNBAR_CONFIG.thresholds.length;  // Default to outer circle
                for (let i = 0; i < DUNBAR_CONFIG.thresholds.length; i++) {
                    if (rank < DUNBAR_CONFIG.thresholds[i]) {
                        circle = i;
                        break;
                    }
                }
                circleMap.set(person.id, circle);
                rank++;
            }

            // Update global map for use in detail view
            dunbarCircleMap = circleMap;

            // Apply circles to original list
            return peopleList.map(p => ({
                ...p,
                dunbar_circle: circleMap.get(p.id) ?? 7
            }));
        }

        // Get Dunbar circle label for display
        function getDunbarCircleLabel(circle) {
            const labels = ['Intimate', 'Close', 'Good Friends', 'Friends', 'Acquaintances', 'Known', 'Familiar', 'Contacts'];
            return labels[circle] || 'Contacts';
        }

        // API helpers
        async function api(path, options = {}) {
            const response = await fetch(`/api/crm${path}`, {
                headers: { 'Content-Type': 'application/json' },
                ...options
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            return response.json();
        }

        // ===============================
        // URL Routing
        // ===============================

        // Parse URL to get person ID and tab
        function parseUrl() {
            const path = window.location.pathname;
            const match = path.match(/^\/crm(?:\/([^\/]+))?(?:\/([^\/]+))?/);
            if (!match) return { personId: null, tab: null };
            return {
                personId: match[1] || null,
                tab: match[2] || null
            };
        }

        // Update URL without reloading page
        function updateUrl(personId, tab, replace = false) {
            let path = '/crm';
            if (personId) {
                path += '/' + personId;
                if (tab && tab !== 'overview') {
                    path += '/' + tab;
                }
            }
            const method = replace ? 'replaceState' : 'pushState';
            history[method]({ personId, tab }, '', path);
        }

        // Handle browser back/forward navigation
        window.addEventListener('popstate', async (event) => {
            const { personId, tab } = parseUrl();
            if (personId) {
                selectedPersonId = personId;
                renderPeopleList();
                await loadPersonDetail(personId, false);
                if (tab) {
                    await switchTab(tab, true); // true = don't update URL
                }
            } else {
                // No person selected - show empty state
                selectedPersonId = null;
                renderPeopleList();
                document.getElementById('detailEmpty').style.display = 'flex';
                document.getElementById('detailContent').style.display = 'none';
            }
        });

        // Initialize
        async function init() {
            await loadPeople();
            await loadStatistics();

            // Restore state from URL
            const { personId, tab } = parseUrl();
            if (personId) {
                await selectPerson(personId, false, true); // true = don't push to history
                if (tab) {
                    await switchTab(tab, true); // true = don't update URL
                }
            }
        }

        // Load people list
        async function loadPeople() {
            const listEl = document.getElementById('peopleList');
            listEl.innerHTML = '<div class="loading">Loading people...</div>';

            try {
                const params = new URLSearchParams();
                if (searchQuery) params.set('q', searchQuery);
                if (currentFilter !== 'all') {
                    params.set('category', currentFilter);
                }
                params.set('sort', 'strength');
                params.set('limit', '100');

                const data = await api(`/people?${params}`);
                people = assignDunbarCircles(data.people);
                renderPeopleList();
            } catch (error) {
                console.error('Failed to load people:', error);
                listEl.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âš ï¸</div><p>Failed to load people</p></div>';
            }
        }

        // Load statistics
        async function loadStatistics() {
            try {
                const data = await api('/statistics');
                document.getElementById('totalPeople').textContent = data.total_people;
            } catch (error) {
                console.error('Failed to load statistics:', error);
            }
        }

        // Render people list
        function renderPeopleList() {
            const listEl = document.getElementById('peopleList');

            if (people.length === 0) {
                listEl.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ‘¥</div><p>No people found</p></div>';
                return;
            }

            listEl.innerHTML = people.map(person => `
                <div class="person-card ${person.id === selectedPersonId ? 'selected' : ''}"
                     onclick="selectPerson('${person.id}')">
                    <div class="person-checkbox ${selectedForMerge.has(person.id) ? 'checked' : ''}"
                         onclick="event.stopPropagation(); toggleMergeSelection('${person.id}')"></div>
                    <div class="person-avatar" style="${getAvatarStyle(person.category)}">${getInitials(person.canonical_name)}</div>
                    <div class="person-info">
                        <div class="person-name">${escapeHtml(person.canonical_name)}</div>
                        <div class="person-company">${escapeHtml(person.company || '')}</div>
                    </div>
                    <div class="dunbar-badge circle-${person.dunbar_circle ?? 7}" title="Dunbar Circle ${person.dunbar_circle ?? 7}">${person.dunbar_circle ?? 7}</div>
                    <div class="person-strength">
                        <div class="person-strength-bar" style="width: ${person.relationship_strength || 0}%"></div>
                    </div>
                </div>
            `).join('');

            updateMergeToolbar();
        }

        // Toggle merge selection for a person
        function toggleMergeSelection(personId) {
            if (selectedForMerge.has(personId)) {
                selectedForMerge.delete(personId);
            } else {
                selectedForMerge.add(personId);
            }
            renderPeopleList();
        }

        // Update merge toolbar visibility and count
        function updateMergeToolbar() {
            const toolbar = document.getElementById('mergeToolbar');
            const countEl = document.getElementById('selectedCount');
            const count = selectedForMerge.size;

            countEl.textContent = count;

            if (count >= 2) {
                toolbar.classList.add('visible');
            } else {
                toolbar.classList.remove('visible');
            }
        }

        // Clear all merge selections
        function clearSelection() {
            selectedForMerge.clear();
            mergePrimaryId = null;
            renderPeopleList();
        }

        // Open merge modal
        function openMergeModal() {
            if (selectedForMerge.size < 2) return;

            const modal = document.getElementById('mergeModal');
            const selectEl = document.getElementById('mergePrimarySelect');
            const secondaryListEl = document.getElementById('mergeSecondaryList');

            // Get selected people details
            const selectedPeople = people.filter(p => selectedForMerge.has(p.id));

            // Render primary selection options
            selectEl.innerHTML = selectedPeople.map(person => `
                <div class="merge-person-option ${mergePrimaryId === person.id ? 'selected' : ''}"
                     onclick="selectMergePrimary('${person.id}')">
                    <div class="person-avatar">${getInitials(person.canonical_name)}</div>
                    <div class="merge-person-details">
                        <div class="merge-person-name">${escapeHtml(person.canonical_name)}</div>
                        <div class="merge-person-meta">
                            ${person.email_count || 0} emails, ${person.meeting_count || 0} meetings, ${person.message_count || 0} messages
                        </div>
                    </div>
                </div>
            `).join('');

            updateMergeSecondaryList();

            modal.classList.add('visible');
        }

        // Select primary person for merge
        function selectMergePrimary(personId) {
            mergePrimaryId = personId;

            // Update selection UI
            document.querySelectorAll('.merge-person-option').forEach(el => {
                el.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            updateMergeSecondaryList();

            // Enable confirm button
            document.getElementById('mergeConfirmBtn').disabled = false;
        }

        // Update secondary list in modal
        function updateMergeSecondaryList() {
            const secondaryListEl = document.getElementById('mergeSecondaryList');
            const selectedPeople = people.filter(p => selectedForMerge.has(p.id) && p.id !== mergePrimaryId);

            if (mergePrimaryId) {
                secondaryListEl.innerHTML = selectedPeople.map(p => `
                    <li>${escapeHtml(p.canonical_name)}</li>
                `).join('');
            } else {
                secondaryListEl.innerHTML = '<li style="color: var(--text-muted);">Select a primary record above</li>';
            }
        }

        // Close merge modal
        function closeMergeModal() {
            document.getElementById('mergeModal').classList.remove('visible');
            mergePrimaryId = null;
            document.getElementById('mergeConfirmBtn').disabled = true;
        }

        // Confirm and execute merge
        async function confirmMerge() {
            if (!mergePrimaryId || selectedForMerge.size < 2) return;

            const secondaryIds = [...selectedForMerge].filter(id => id !== mergePrimaryId);

            try {
                const btn = document.getElementById('mergeConfirmBtn');
                btn.disabled = true;
                btn.textContent = 'Merging...';

                const result = await api('/people/merge', {
                    method: 'POST',
                    body: JSON.stringify({
                        primary_id: mergePrimaryId,
                        secondary_ids: secondaryIds
                    })
                });

                console.log('Merge completed:', result);

                // Close modal and refresh
                closeMergeModal();
                clearSelection();
                await loadPeople();

                // Show success (select the merged person)
                selectPerson(mergePrimaryId);

            } catch (error) {
                console.error('Merge failed:', error);
                alert('Merge failed: ' + error.message);
            } finally {
                const btn = document.getElementById('mergeConfirmBtn');
                btn.disabled = false;
                btn.textContent = 'Merge';
            }
        }

        // ===============================
        // Split Modal Functions
        // ===============================

        let splitContactSources = [];  // Aggregated contact sources (emails, phones, etc.)
        let selectedContactSources = new Set();  // Set of identifier keys (e.g., "email:foo@bar.com")
        let splitTargetType = null;  // 'existing' or 'new'
        let splitTargetPersonId = null;
        let splitFromPersonId = null;

        async function openSplitModal() {
            if (!selectedPersonId) return;

            splitFromPersonId = selectedPersonId;
            selectedContactSources.clear();
            splitTargetType = null;
            splitTargetPersonId = null;

            // Get person name
            const person = people.find(p => p.id === selectedPersonId);
            document.getElementById('splitFromPersonName').textContent = person?.canonical_name || 'this person';

            // Show modal
            document.getElementById('splitModal').classList.add('visible');
            document.getElementById('splitSourceList').innerHTML = '<div class="loading">Loading contact sources...</div>';
            updateSplitButton();

            // Load contact sources (aggregated by identifier: email, phone, etc.)
            try {
                const data = await api(`/people/${selectedPersonId}/contact-sources`);
                splitContactSources = data.contact_sources;
                renderSplitSourceList();
            } catch (error) {
                console.error('Failed to load contact sources:', error);
                document.getElementById('splitSourceList').innerHTML =
                    '<div style="padding: 1rem; color: var(--error);">Failed to load contact sources</div>';
            }
        }

        function renderSplitSourceList() {
            const listEl = document.getElementById('splitSourceList');

            if (splitContactSources.length === 0) {
                listEl.innerHTML = '<div style="padding: 1rem; color: var(--text-secondary);">No contact sources found</div>';
                return;
            }

            // Icons for identifier types
            const typeIcons = {
                'email': 'ðŸ“§',
                'phone': 'ðŸ“±',
                'slack_user': 'ðŸ’¬',
                'linkedin_profile': 'ðŸ’¼',
                'name_only': 'ðŸ‘¤'
            };

            // Display names for identifier types
            const typeLabels = {
                'email': 'Email',
                'phone': 'Phone',
                'slack_user': 'Slack',
                'linkedin_profile': 'LinkedIn',
                'name_only': 'Name'
            };

            listEl.innerHTML = splitContactSources.map(cs => {
                const key = `${cs.identifier_type}:${cs.identifier}`;
                const isSelected = selectedContactSources.has(key);
                const icon = typeIcons[cs.identifier_type] || 'ðŸ“„';
                const label = typeLabels[cs.identifier_type] || cs.identifier_type;
                const names = cs.observed_names?.length > 0 ? cs.observed_names.join(', ') : '';
                const sources = cs.source_types?.join(', ') || '';

                return `
                    <div class="split-source-item ${isSelected ? 'selected' : ''}"
                         onclick="toggleContactSource('${escapeHtml(key)}')">
                        <input type="checkbox" class="split-source-checkbox"
                               ${isSelected ? 'checked' : ''}
                               onclick="event.stopPropagation(); toggleContactSource('${escapeHtml(key)}')">
                        <span class="split-source-badge">${icon} ${label}</span>
                        <div class="split-source-info">
                            <div class="split-source-name">${escapeHtml(cs.identifier)}</div>
                            <div class="split-source-meta">
                                ${names ? `Names: ${escapeHtml(names)} Â· ` : ''}
                                Sources: ${escapeHtml(sources)} Â·
                                ${cs.observation_count} observation${cs.observation_count !== 1 ? 's' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleContactSource(key) {
            if (selectedContactSources.has(key)) {
                selectedContactSources.delete(key);
            } else {
                selectedContactSources.add(key);
            }
            renderSplitSourceList();
            updateSplitButton();
        }

        // Get all source_entity_ids for selected contact sources
        function getSelectedSourceEntityIds() {
            const allIds = [];
            for (const key of selectedContactSources) {
                const cs = splitContactSources.find(c => `${c.identifier_type}:${c.identifier}` === key);
                if (cs && cs.source_entity_ids) {
                    allIds.push(...cs.source_entity_ids);
                }
            }
            return allIds;
        }

        function setSplitTarget(type) {
            splitTargetType = type;
            splitTargetPersonId = null;

            // Update radio button states
            document.querySelectorAll('.split-target-option').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelector(`.split-target-option input[value="${type}"]`)?.closest('.split-target-option')?.classList.add('selected');

            // Show/hide sections
            document.getElementById('splitExistingSection').style.display = type === 'existing' ? 'block' : 'none';
            document.getElementById('splitNewSection').style.display = type === 'new' ? 'block' : 'none';

            updateSplitButton();
        }

        async function searchSplitTarget() {
            const query = document.getElementById('splitPersonSearch').value.trim();
            const resultsEl = document.getElementById('splitPersonResults');

            if (query.length < 2) {
                resultsEl.innerHTML = '';
                return;
            }

            try {
                const data = await api(`/people?q=${encodeURIComponent(query)}&limit=10`);
                const filtered = data.people.filter(p => p.id !== splitFromPersonId);

                if (filtered.length === 0) {
                    resultsEl.innerHTML = '<div style="padding: 0.5rem; color: var(--text-secondary);">No matching people</div>';
                    return;
                }

                resultsEl.innerHTML = filtered.map(p => `
                    <div class="split-person-result ${splitTargetPersonId === p.id ? 'selected' : ''}"
                         onclick="selectSplitTarget('${p.id}', '${escapeHtml(p.canonical_name)}')">
                        ${escapeHtml(p.canonical_name)}
                        ${p.company ? `<span style="color: var(--text-secondary);"> Â· ${escapeHtml(p.company)}</span>` : ''}
                    </div>
                `).join('');
            } catch (error) {
                console.error('Search failed:', error);
            }
        }

        function selectSplitTarget(personId, personName) {
            splitTargetPersonId = personId;
            document.getElementById('splitPersonSearch').value = personName;
            document.getElementById('splitPersonResults').innerHTML = '';
            updateSplitButton();
        }

        function updateSplitButton() {
            const btn = document.getElementById('splitConfirmBtn');
            const countEl = document.getElementById('splitCount');

            countEl.textContent = selectedContactSources.size;

            // Enable if we have sources selected AND a valid target
            const hasTarget = (splitTargetType === 'existing' && splitTargetPersonId) ||
                              (splitTargetType === 'new' && document.getElementById('splitNewPersonName').value.trim());
            const hasSelection = selectedContactSources.size > 0;

            btn.disabled = !(hasSelection && hasTarget);
        }

        function closeSplitModal() {
            document.getElementById('splitModal').classList.remove('visible');
            splitContactSources = [];
            selectedContactSources.clear();
            splitTargetType = null;
            splitTargetPersonId = null;
            splitFromPersonId = null;
        }

        async function confirmSplit() {
            if (selectedContactSources.size === 0) return;

            const btn = document.getElementById('splitConfirmBtn');
            btn.disabled = true;
            btn.textContent = 'Splitting...';

            try {
                // Get all source entity IDs from selected contact sources
                const sourceEntityIds = getSelectedSourceEntityIds();
                const requestBody = {
                    from_person_id: splitFromPersonId,
                    source_entity_ids: sourceEntityIds,
                    create_overrides: document.getElementById('splitCreateOverrides').checked
                };

                if (splitTargetType === 'existing') {
                    requestBody.to_person_id = splitTargetPersonId;
                } else {
                    requestBody.new_person_name = document.getElementById('splitNewPersonName').value.trim();
                }

                const result = await api('/people/split', {
                    method: 'POST',
                    body: JSON.stringify(requestBody)
                });

                console.log('Split completed:', result);

                // Close modal and refresh
                closeSplitModal();
                await loadPeople();

                // Reload the current person's details
                await loadPersonDetail(splitFromPersonId || selectedPersonId);

                // Show success message
                alert(`Split complete! Moved ${result.source_entities_moved} sources and ${result.interactions_moved} interactions.` +
                      (result.overrides_created > 0 ? ` Created ${result.overrides_created} disambiguation rules.` : ''));

            } catch (error) {
                console.error('Split failed:', error);
                alert('Split failed: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Split <span id="splitCount">0</span> Sources';
            }
        }

        // Listen for input changes on new person name field
        document.addEventListener('DOMContentLoaded', () => {
            const newNameInput = document.getElementById('splitNewPersonName');
            if (newNameInput) {
                newNameInput.addEventListener('input', updateSplitButton);
            }
        });

        // ===============================
        // End Split Modal Functions
        // ===============================

        // Select a person
        async function selectPerson(personId, stayOnCurrentTab = false, skipUrlUpdate = false) {
            selectedPersonId = personId;
            renderPeopleList();
            await loadPersonDetail(personId, stayOnCurrentTab);

            // Update URL (unless called from popstate or initial load)
            if (!skipUrlUpdate) {
                const currentTab = document.querySelector('.tab.active')?.dataset.tab || 'overview';
                updateUrl(personId, currentTab);
            }
        }

        // Load person detail
        async function loadPersonDetail(personId, stayOnCurrentTab = false) {
            // Clear any date filter when loading a new person
            window.timelineDateFilter = null;

            const emptyEl = document.getElementById('detailEmpty');
            const contentEl = document.getElementById('detailContent');

            emptyEl.style.display = 'none';
            contentEl.style.display = 'flex';
            contentEl.style.flexDirection = 'column';
            contentEl.style.height = '100%';

            // Remember current tab if we should stay on it
            const currentTab = document.querySelector('.tab.active')?.dataset.tab || 'overview';

            try {
                const person = await api(`/people/${personId}?include_related=true`);
                renderPersonDetail(person);

                // Load data for the active tab
                const activeTab = stayOnCurrentTab ? currentTab : document.querySelector('.tab.active')?.dataset.tab;
                if (activeTab === 'timeline') {
                    await loadTimeline(personId);
                } else if (activeTab === 'graph') {
                    await loadGraph(personId);
                }
            } catch (error) {
                console.error('Failed to load person detail:', error);
            }
        }

        // Render person detail
        function renderPersonDetail(person) {
            document.getElementById('detailAvatar').textContent = getInitials(person.canonical_name);
            document.getElementById('detailName').textContent = person.canonical_name;
            document.getElementById('detailCompany').textContent = [person.company, person.position].filter(Boolean).join(' Â· ');

            // Quick contact links in header
            const quickContactEl = document.getElementById('detailContactQuick');
            let quickContactHtml = '';
            if (person.emails && person.emails.length > 0) {
                quickContactHtml += `<a href="mailto:${person.emails[0]}" class="detail-contact-link">ðŸ“§ ${escapeHtml(person.emails[0])}</a>`;
            }
            if (person.phone_numbers && person.phone_numbers.length > 0) {
                quickContactHtml += `<a href="tel:${person.phone_numbers[0]}" class="detail-contact-link">ðŸ“ž ${escapeHtml(person.phone_numbers[0])}</a>`;
            }
            quickContactEl.innerHTML = quickContactHtml;

            // Editable tags in header
            renderEditableTags(person.tags || []);

            // Load Quick Facts (will auto-extract if none exist)
            loadFacts(person.id);

            // Hero stats row
            renderHeroStats(person);

            // Relationship strength ring
            renderStrengthRing(person.relationship_strength || 0);

            // Dunbar circle display
            renderDunbarCircle(person.id);

            // Backwards compatibility for old strength breakdown (hidden)
            renderStrengthBreakdown(person);

            // Heat map calendar - load from timeline or generate empty
            loadAndRenderHeatMap(person.id);

            // Compact contact info for new layout
            renderCompactContactInfo(person);

            // Legacy contact info (hidden for backwards compatibility)
            const contactEl = document.getElementById('contactInfo');
            let contactHtml = '';

            if (person.emails && person.emails.length > 0) {
                contactHtml += `<div class="info-item"><div class="info-label">Email${person.emails.length > 1 ? 's' : ''}</div><div class="info-value">${person.emails.map(e => `<a href="mailto:${e}">${escapeHtml(e)}</a>`).join('<br>')}</div></div>`;
            }
            if (person.phone_numbers && person.phone_numbers.length > 0) {
                contactHtml += `<div class="info-item"><div class="info-label">Phone${person.phone_numbers.length > 1 ? 's' : ''}</div><div class="info-value">${person.phone_numbers.map(p => `<a href="tel:${p}">${escapeHtml(p)}</a>`).join('<br>')}</div></div>`;
            }
            if (person.linkedin_url) {
                contactHtml += `<div class="info-item"><div class="info-label">LinkedIn</div><div class="info-value"><a href="${person.linkedin_url}" target="_blank">View Profile</a></div></div>`;
            }
            if (person.category) {
                contactHtml += `<div class="info-item"><div class="info-label">Category</div><div class="info-value">${escapeHtml(person.category)}</div></div>`;
            }
            if (person.first_seen) {
                contactHtml += `<div class="info-item"><div class="info-label">First Seen</div><div class="info-value">${formatDate(person.first_seen)}</div></div>`;
            }
            if (person.last_seen) {
                contactHtml += `<div class="info-item"><div class="info-label">Last Seen</div><div class="info-value">${formatDate(person.last_seen)}</div></div>`;
            }

            contactEl.innerHTML = contactHtml || '<div class="info-item"><div class="info-value">No contact info</div></div>';

            // Notes
            document.getElementById('notesArea').value = person.notes || '';

            // Source entities - use the count field, not array length (array may not be fully loaded)
            const sourceEntities = person.source_entities || [];
            const sourceEntityCount = person.source_entity_count || sourceEntities.length;
            document.getElementById('sourceEntitiesCount').textContent = sourceEntityCount.toLocaleString();
            const listEl = document.getElementById('sourceEntitiesList');

            if (sourceEntities.length > 0) {
                listEl.innerHTML = sourceEntities.map(se => `
                    <div class="source-entity-item">
                        <span class="source-entity-badge">${se.source_badge}</span>
                        <div class="source-entity-info">
                            <div class="source-entity-name">${escapeHtml(se.observed_name || se.observed_email || 'Unknown')}</div>
                            <div class="source-entity-meta">${se.source_type} Â· ${formatDate(se.observed_at)}</div>
                        </div>
                        <span class="source-entity-status ${se.link_status}">${se.link_status}</span>
                    </div>
                `).join('');
            } else {
                listEl.innerHTML = '<div class="empty-state"><p>No source entities</p></div>';
            }
        }

        // Render editable tags
        function renderEditableTags(tags) {
            const container = document.getElementById('detailTagsChips');
            let html = tags.map(tag => `
                <span class="detail-tag-chip">
                    ${escapeHtml(tag)}
                    <span class="remove-tag" onclick="removeTag('${escapeHtml(tag)}')">Ã—</span>
                </span>
            `).join('');
            html += `<span class="detail-tag-add" onclick="addTag()">+ Add tag</span>`;
            container.innerHTML = html;
        }

        // Format large numbers compactly (e.g., 46049 -> "46K")
        function formatCompactNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
            return num.toString();
        }

        // Render hero stats row
        function renderHeroStats(person) {
            const emailCount = person.email_count || 0;
            const eventCount = person.meeting_count || 0; // "events" instead of "meetings"
            const messageCount = person.message_count || 0; // iMessage + WhatsApp combined

            document.getElementById('heroStatEmails').textContent = formatCompactNumber(emailCount);
            document.getElementById('heroStatEvents').textContent = formatCompactNumber(eventCount);
            document.getElementById('heroStatMessages').textContent = formatCompactNumber(messageCount);

            // First seen date
            if (person.first_seen) {
                const firstSeenDate = new Date(person.first_seen);
                const options = { month: 'short', day: 'numeric' };
                // Add year if not current year
                if (firstSeenDate.getFullYear() !== new Date().getFullYear()) {
                    options.year = 'numeric';
                }
                document.getElementById('heroStatFirstSeen').textContent = firstSeenDate.toLocaleDateString('en-US', options);
            } else {
                document.getElementById('heroStatFirstSeen').textContent = 'â€”';
            }

            // Backwards compat for hidden stats
            document.getElementById('statEmails').textContent = emailCount;
            document.getElementById('statMeetings').textContent = eventCount;
            document.getElementById('statMessages').textContent = messageCount;
            document.getElementById('statNotes').textContent = person.notes ? 1 : 0;
        }

        // Render strength ring (circular progress indicator)
        function renderStrengthRing(strength) {
            const strengthValue = Math.round(strength);
            const ringFill = document.getElementById('strengthRingFill');
            const ringValueEl = document.getElementById('strengthRingValue');

            // Circle circumference = 2 * PI * r = 2 * 3.14159 * 13 = 81.68
            const circumference = 81.68;
            const offset = circumference - (circumference * strengthValue / 100);

            ringFill.style.strokeDashoffset = offset;
            ringValueEl.textContent = strengthValue;
        }

        // Render Dunbar circle indicator
        function renderDunbarCircle(personId) {
            const indicatorEl = document.getElementById('dunbarCircleIndicator');
            const labelEl = document.getElementById('dunbarCircleLabel');
            if (!indicatorEl || !labelEl) return;

            const circle = dunbarCircleMap.get(personId) ?? 7;
            indicatorEl.textContent = circle;
            indicatorEl.className = `dunbar-circle-indicator circle-${circle}`;
            labelEl.textContent = getDunbarCircleLabel(circle);
        }

        // Render compact contact info for new two-column layout
        function renderCompactContactInfo(person) {
            const container = document.getElementById('contactInfoCompact');
            if (!container) return;

            let html = '';

            // Emails
            if (person.emails && person.emails.length > 0) {
                html += `
                    <div class="contact-row">
                        <div class="contact-icon-box">ðŸ“§</div>
                        <div class="contact-values">
                            ${person.emails.map(e => `<a href="mailto:${e}" class="contact-value-link">${escapeHtml(e)}</a>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Phone numbers
            if (person.phone_numbers && person.phone_numbers.length > 0) {
                html += `
                    <div class="contact-row">
                        <div class="contact-icon-box">ðŸ“ž</div>
                        <div class="contact-values">
                            ${person.phone_numbers.map(p => `<a href="tel:${p}" class="contact-value-link">${escapeHtml(p)}</a>`).join('')}
                        </div>
                    </div>
                `;
            }

            // LinkedIn
            if (person.linkedin_url) {
                html += `
                    <div class="contact-row">
                        <div class="contact-icon-box">ðŸ”—</div>
                        <div class="contact-values">
                            <a href="${person.linkedin_url}" target="_blank" class="contact-value-link">LinkedIn Profile</a>
                        </div>
                    </div>
                `;
            }

            // Meta info (First Seen, Last Seen, Category)
            const metaItems = [];
            if (person.first_seen) {
                metaItems.push(`
                    <div class="contact-meta-item">
                        <span class="contact-meta-label">First seen</span>
                        <span class="contact-meta-value">${formatDate(person.first_seen)}</span>
                    </div>
                `);
            }
            if (person.last_seen) {
                metaItems.push(`
                    <div class="contact-meta-item">
                        <span class="contact-meta-label">Last seen</span>
                        <span class="contact-meta-value">${formatDate(person.last_seen)}</span>
                    </div>
                `);
            }
            if (person.category) {
                metaItems.push(`
                    <div class="contact-meta-item">
                        <span class="contact-meta-label">Category</span>
                        <span class="contact-meta-value">${escapeHtml(person.category)}</span>
                    </div>
                `);
            }

            if (metaItems.length > 0) {
                html += `<div class="contact-meta-row">${metaItems.join('')}</div>`;
            }

            container.innerHTML = html || '<div style="color: var(--text-muted); font-size: 0.8125rem;">No contact info</div>';
        }

        // Add tag
        async function addTag() {
            const tag = prompt('Enter tag name:');
            if (!tag || !selectedPersonId) return;

            try {
                const person = await api(`/people/${selectedPersonId}`);
                const tags = person.tags || [];
                if (!tags.includes(tag)) {
                    tags.push(tag);
                    await api(`/people/${selectedPersonId}`, {
                        method: 'PATCH',
                        body: JSON.stringify({ tags })
                    });
                    await loadPersonDetail(selectedPersonId);
                }
            } catch (error) {
                console.error('Failed to add tag:', error);
            }
        }

        // Remove tag
        async function removeTag(tag) {
            if (!selectedPersonId) return;

            try {
                const person = await api(`/people/${selectedPersonId}`);
                const tags = (person.tags || []).filter(t => t !== tag);
                await api(`/people/${selectedPersonId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ tags })
                });
                await loadPersonDetail(selectedPersonId);
            } catch (error) {
                console.error('Failed to remove tag:', error);
            }
        }

        // Render relationship strength breakdown
        function renderStrengthBreakdown(person) {
            const strength = person.relationship_strength || 0;
            document.getElementById('strengthBarFill').style.width = `${strength}%`;

            // Calculate components (mock calculation based on available data)
            const components = [
                { icon: 'ðŸ“§', label: 'Emails', value: Math.min(1, (person.email_count || 0) / 50).toFixed(2) },
                { icon: 'ðŸ“…', label: 'Meetings', value: Math.min(1, (person.meeting_count || 0) / 20).toFixed(2) },
                { icon: 'ðŸ•', label: 'Recency', value: calculateRecencyScore(person.last_seen) },
                { icon: 'ðŸ“Š', label: 'Frequency', value: Math.min(1, (person.email_count + person.meeting_count) / 100).toFixed(2) }
            ];

            const componentsEl = document.getElementById('strengthComponents');
            componentsEl.innerHTML = components.map(c => `
                <div class="strength-component">
                    <div class="strength-component-icon">${c.icon}</div>
                    <div class="strength-component-info">
                        <div class="strength-component-label">${c.label}</div>
                        <div class="strength-component-value">${c.value}</div>
                    </div>
                </div>
            `).join('');
        }

        // Calculate recency score
        function calculateRecencyScore(lastSeen) {
            if (!lastSeen) return '0.00';
            const now = new Date();
            const last = new Date(lastSeen);
            const daysDiff = (now - last) / (1000 * 60 * 60 * 24);

            if (daysDiff < 7) return '1.00';
            if (daysDiff < 30) return '0.75';
            if (daysDiff < 90) return '0.50';
            if (daysDiff < 180) return '0.25';
            return '0.10';
        }

        // Heatmap data store for tooltips
        let heatmapData = {};

        // Source type badges mapping
        const SOURCE_BADGES = {
            'imessage': { badge: String.fromCodePoint(0x1F4AC), label: 'iMessages' },
            'gmail': { badge: String.fromCodePoint(0x1F4E7), label: 'Emails' },
            'calendar': { badge: String.fromCodePoint(0x1F4C5), label: 'Meetings' },
            'slack': { badge: String.fromCodePoint(0x1F4DD), label: 'Slack' },
            'linkedin': { badge: String.fromCodePoint(0x1F465), label: 'LinkedIn' },
            'vault': { badge: String.fromCodePoint(0x1F4C4), label: 'Notes' },
            'whatsapp': { badge: String.fromCodePoint(0x1F4F1), label: 'WhatsApp' },
            'signal': { badge: String.fromCodePoint(0x1F510), label: 'Signal' }
        };

        // Load and render heat map
        async function loadAndRenderHeatMap(personId) {
            const grid = document.getElementById('heatmapGrid');
            const monthsContainer = document.getElementById('heatmapMonths');

            try {
                // Use aggregated timeline endpoint for efficient data loading
                const data = await api(`/people/${personId}/timeline/aggregated?days_back=372`);
                const days = data.days || [];

                // Build interaction history with source breakdown
                heatmapData = {};
                days.forEach(day => {
                    const dateKey = day.date;
                    heatmapData[dateKey] = { total: day.total_count, sources: {} };
                    (day.groups || []).forEach(group => {
                        const sourceType = (group.source_type || 'unknown').toLowerCase();
                        heatmapData[dateKey].sources[sourceType] = group.count;
                    });
                });

                renderHeatMap();
            } catch (error) {
                console.error('Failed to load heat map:', error);
                heatmapData = {};
                renderHeatMap();
            }
        }

        // Render heat map in GitHub contribution graph style
        function renderHeatMap() {
            const grid = document.getElementById('heatmapGrid');
            const monthsContainer = document.getElementById('heatmapMonths');
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Calculate start date (go back ~52 weeks, starting from Sunday)
            const endDate = new Date(today);
            const startDate = new Date(today);
            startDate.setDate(startDate.getDate() - 364);

            // Adjust to start on a Sunday
            const startDayOfWeek = startDate.getDay();
            startDate.setDate(startDate.getDate() - startDayOfWeek);

            // Constants for pixel calculations
            const daySize = 10; // px
            const gap = 2; // px between days/weeks
            const weekWidth = daySize + gap; // width per week column

            // Generate weeks (columns)
            let weeksHtml = '';
            let currentDate = new Date(startDate);
            let monthLabels = [];
            let weekIndex = 0;
            let lastMonth = -1;

            while (currentDate <= endDate) {
                weeksHtml += '<div class="heatmap-week">';

                for (let day = 0; day < 7; day++) {
                    const dateKey = currentDate.toISOString().split('T')[0];
                    const dayData = heatmapData[dateKey] || { total: 0, sources: {} };
                    const count = dayData.total;

                    // Calculate level (0-5)
                    let level = 0;
                    if (count > 0) level = 1;
                    if (count >= 3) level = 2;
                    if (count >= 6) level = 3;
                    if (count >= 10) level = 4;
                    if (count >= 20) level = 5;

                    // Track month changes at the START of each week (Sunday)
                    // This way the label aligns with the week column
                    if (day === 0) {
                        const currentMonth = currentDate.getMonth();
                        if (currentMonth !== lastMonth && currentDate >= startDate && currentDate <= endDate) {
                            const monthName = currentDate.toLocaleDateString('en-US', { month: 'short' });
                            monthLabels.push({ weekIndex, monthName, month: currentMonth });
                            lastMonth = currentMonth;
                        }
                    }

                    // Only render if within valid date range
                    if (currentDate > endDate || currentDate < startDate) {
                        weeksHtml += '<div class="heatmap-day" style="visibility:hidden"></div>';
                    } else {
                        weeksHtml += `<div class="heatmap-day" data-level="${level}" data-date="${dateKey}"></div>`;
                    }

                    currentDate.setDate(currentDate.getDate() + 1);
                }

                weeksHtml += '</div>';
                weekIndex++;
            }

            grid.innerHTML = weeksHtml;

            // Generate month labels with precise pixel positioning
            const totalWeeks = weekIndex;
            let monthsHtml = '';

            for (let i = 0; i < monthLabels.length; i++) {
                const label = monthLabels[i];
                const nextLabel = monthLabels[i + 1];

                // Calculate width based on weeks this month spans
                const nextWeekIndex = nextLabel ? nextLabel.weekIndex : totalWeeks;
                const weeksSpan = nextWeekIndex - label.weekIndex;
                const widthPx = weeksSpan * weekWidth - gap; // subtract gap for last column

                monthsHtml += `<div class="heatmap-month-label" style="width: ${widthPx}px; min-width: ${widthPx}px;">${label.monthName}</div>`;
            }
            monthsContainer.innerHTML = monthsHtml;

            // Setup tooltip and click handlers
            setupHeatmapInteractions();
        }

        // Setup tooltip and click interactions for heatmap
        function setupHeatmapInteractions() {
            const tooltip = document.getElementById('heatmapTooltip');
            const days = document.querySelectorAll('.heatmap-day[data-date]');

            days.forEach(day => {
                day.addEventListener('mouseenter', (e) => {
                    const dateKey = day.dataset.date;
                    const dayData = heatmapData[dateKey] || { total: 0, sources: {} };

                    // Format date nicely
                    const dateObj = new Date(dateKey + 'T12:00:00');
                    const dateStr = dateObj.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric',
                        year: 'numeric'
                    });

                    // Build tooltip content
                    let html = `<div class="heatmap-tooltip-date">${dateStr}</div>`;

                    if (dayData.total === 0) {
                        html += '<div class="heatmap-tooltip-item">No interactions</div>';
                    } else {
                        // Sort sources by count descending
                        const sortedSources = Object.entries(dayData.sources)
                            .sort((a, b) => b[1] - a[1]);

                        sortedSources.forEach(([sourceType, count]) => {
                            const sourceInfo = SOURCE_BADGES[sourceType] || { badge: String.fromCodePoint(0x1F4C4), label: sourceType };
                            html += `<div class="heatmap-tooltip-item">${sourceInfo.badge} ${count} ${sourceInfo.label}</div>`;
                        });

                        html += `<div class="heatmap-tooltip-total">Total: ${dayData.total} interaction${dayData.total !== 1 ? 's' : ''}</div>`;
                    }

                    tooltip.innerHTML = html;

                    // Position tooltip
                    const rect = day.getBoundingClientRect();
                    tooltip.style.left = `${rect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - 8}px`;
                    tooltip.style.transform = 'translate(-50%, -100%)';
                    tooltip.classList.add('visible');
                });

                day.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });

                day.addEventListener('click', () => {
                    const dateKey = day.dataset.date;
                    navigateToTimelineDate(dateKey);
                });
            });
        }

        // Navigate to timeline tab filtered to a specific date
        async function navigateToTimelineDate(dateKey) {
            // IMPORTANT: Set the filter BEFORE switching tabs
            // This ensures the filter is active when loadTimeline() runs
            window.timelineDateFilter = dateKey;

            // Switch to timeline tab - this will load and render timeline with the filter applied
            await switchTab('timeline');
        }

        // Render timeline filtered to a specific date
        function renderTimelineWithDateFilter() {
            const container = document.getElementById('timelineContainer');
            const dateKey = window.timelineDateFilter;

            if (!dateKey) {
                renderTimeline();
                return;
            }

            // Filter items to the specific date
            const targetDate = new Date(dateKey + 'T00:00:00');
            const nextDate = new Date(targetDate);
            nextDate.setDate(nextDate.getDate() + 1);

            let items = timelineData.filter(item => {
                const itemDate = new Date(item.timestamp);
                return itemDate >= targetDate && itemDate < nextDate;
            });

            // Apply source filter if active
            if (timelineFilter !== 'all') {
                items = items.filter(item => {
                    const sourceType = (item.source_type || '').toLowerCase();
                    return sourceType.includes(timelineFilter);
                });
            }

            // Show date filter banner
            const formattedDate = targetDate.toLocaleDateString('en-US', {
                weekday: 'long',
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            });

            if (items.length === 0) {
                container.innerHTML = `
                    <div class="timeline-date-filter">
                        <span>Showing ${formattedDate}</span>
                        <button onclick="clearTimelineDateFilter()">Clear filter</button>
                    </div>
                    <div class="empty-state">
                        <div class="empty-state-icon">${String.fromCodePoint(0x1F4C5)}</div>
                        <p>No interactions on this day</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div class="timeline-date-filter">
                    <span>Showing ${formattedDate} (${items.length} interaction${items.length !== 1 ? 's' : ''})</span>
                    <button onclick="clearTimelineDateFilter()">Clear filter</button>
                </div>
            ` + items.map(item => `
                <div class="timeline-item">
                    <div class="timeline-badge">${item.source_badge || String.fromCodePoint(0x1F4C4)}</div>
                    <div class="timeline-content">
                        <div class="timeline-title">
                            ${item.source_link ? `<a href="${item.source_link}" target="_blank">${escapeHtml(item.title)}</a>` : escapeHtml(item.title)}
                        </div>
                        ${item.snippet ? `<div class="timeline-snippet">${escapeHtml(item.snippet)}</div>` : ''}
                        <div class="timeline-meta">
                            ${formatDate(item.timestamp)}
                            <span class="timeline-source-badge">${escapeHtml(item.source_type || 'Unknown')}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Clear timeline date filter
        function clearTimelineDateFilter() {
            window.timelineDateFilter = null;
            renderTimeline();
        }

        // Load timeline
        async function loadTimeline(personId) {
            const container = document.getElementById('timelineContainer');
            container.innerHTML = '<div class="loading">Loading timeline...</div>';

            try {
                // If date filter is active, load full year of data to match heatmap
                // Otherwise, use default limit for performance
                let url = `/people/${personId}/timeline`;
                if (window.timelineDateFilter) {
                    url += '?days_back=372&limit=1500';
                } else {
                    url += '?limit=100';
                }
                const data = await api(url);
                timelineData = data.items || [];
                renderTimeline();
            } catch (error) {
                console.error('Failed to load timeline:', error);
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âš ï¸</div><p>Failed to load timeline</p></div>';
            }
        }

        // Render timeline with current filter
        function renderTimeline() {
            // If date filter is active, use the date-filtered render
            if (window.timelineDateFilter) {
                renderTimelineWithDateFilter();
                return;
            }

            const container = document.getElementById('timelineContainer');

            // Filter items
            let items = timelineData;
            if (timelineFilter !== 'all') {
                items = timelineData.filter(item => {
                    const sourceType = (item.source_type || '').toLowerCase();
                    return sourceType.includes(timelineFilter);
                });
            }

            if (items.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“…</div><p>No interactions found</p></div>';
                return;
            }

            container.innerHTML = items.map(item => `
                <div class="timeline-item">
                    <div class="timeline-badge">${item.source_badge || 'ðŸ“„'}</div>
                    <div class="timeline-content">
                        <div class="timeline-title">
                            ${item.source_link ? `<a href="${item.source_link}" target="_blank">${escapeHtml(item.title)}</a>` : escapeHtml(item.title)}
                        </div>
                        ${item.snippet ? `<div class="timeline-snippet">${escapeHtml(item.snippet)}</div>` : ''}
                        <div class="timeline-meta">
                            ${formatDate(item.timestamp)}
                            <span class="timeline-source-badge">${escapeHtml(item.source_type || 'Unknown')}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Filter timeline
        function filterTimeline(source) {
            timelineFilter = source;

            // Update UI
            document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
            document.querySelector(`[data-source="${source}"]`).classList.add('active');

            renderTimeline();
        }

        // Quick Facts state
        let factsData = [];
        let autoExtractInProgress = false; // Prevent multiple auto-extracts

        // Load facts for a person
        async function loadFacts(personId) {
            const container = document.getElementById('factsContainer');

            try {
                const data = await api(`/people/${personId}/facts`);
                factsData = data.facts || [];
                const byCategory = data.by_category || {};
                renderFacts(byCategory);

                // Auto-trigger extraction if no facts exist
                const hasAnyFacts = Object.values(byCategory).some(facts => facts && facts.length > 0);
                if (!hasAnyFacts && !autoExtractInProgress && selectedPersonId === personId) {
                    autoExtractInProgress = true;
                    console.log('No facts found, auto-triggering extraction...');
                    // Small delay to let the UI render first
                    setTimeout(() => {
                        extractFacts().finally(() => {
                            autoExtractInProgress = false;
                        });
                    }, 500);
                }
            } catch (error) {
                console.error('Failed to load facts:', error);
                container.innerHTML = '<div class="facts-empty">Failed to load facts.</div>';
            }
        }

        // Render facts grouped by category
        function renderFacts(byCategory) {
            const container = document.getElementById('factsContainer');

            // Include summary category at the end
            const categoryOrder = ['summary', 'family', 'work', 'background', 'interests', 'preferences', 'dates', 'topics', 'travel'];
            const categoryIcons = {
                'family': String.fromCodePoint(0x1F468, 0x200D, 0x1F469, 0x200D, 0x1F467),  // family emoji
                'preferences': String.fromCodePoint(0x2699, 0xFE0F),  // gear
                'background': String.fromCodePoint(0x1F3E0),  // house
                'interests': String.fromCodePoint(0x1F3AF),  // target
                'dates': String.fromCodePoint(0x1F4C5),  // calendar
                'work': String.fromCodePoint(0x1F4BC),  // briefcase
                'topics': String.fromCodePoint(0x1F4AC),  // speech bubble
                'travel': String.fromCodePoint(0x2708, 0xFE0F),  // airplane
                'summary': String.fromCodePoint(0x1F4CA),  // chart emoji
            };

            // Display names for categories
            const categoryNames = {
                'summary': 'Relationship Insights',
                'family': 'Family',
                'work': 'Work',
                'background': 'Background',
                'interests': 'Interests',
                'preferences': 'Preferences',
                'dates': 'Important Dates',
                'topics': 'Topics',
                'travel': 'Travel',
            };

            // Check if we have any facts
            const hasAnyFacts = Object.values(byCategory).some(facts => facts && facts.length > 0);

            if (!hasAnyFacts) {
                container.innerHTML = '<div class="facts-empty">No facts extracted yet. Click "Extract Facts" to analyze interactions.</div>';
                return;
            }

            let html = '';
            for (const category of categoryOrder) {
                const facts = byCategory[category];
                if (!facts || facts.length === 0) continue;

                const icon = categoryIcons[category] || '';
                const displayName = categoryNames[category] || (category.charAt(0).toUpperCase() + category.slice(1));

                html += `
                    <div class="facts-category ${category}">
                        <div class="facts-category-header">
                            <span class="facts-category-icon">${icon}</span>
                            <span>${displayName}</span>
                        </div>
                        <ul class="facts-list">
                            ${facts.map(fact => renderFactItem(fact)).join('')}
                        </ul>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Render a single fact as a bullet point
        function renderFactItem(fact) {
            const unconfirmedClass = fact.confirmed_by_user ? '' : 'unconfirmed';
            const factSentence = formatFactAsSentence(fact.key, fact.value);
            const confidencePercent = Math.round(fact.confidence * 100);

            // Confidence level class
            const confLevel = fact.confidence >= 0.8 ? 'high' : (fact.confidence >= 0.5 ? 'medium' : 'low');

            // Source link (clickable to open Gmail/Calendar/Obsidian)
            const sourceLinkHtml = fact.source_link ?
                `<a href="${escapeHtml(fact.source_link)}" class="fact-source-link" target="_blank" onclick="event.stopPropagation();" title="View source">
                    <span class="fact-source-link-icon">${getSourceIcon(fact.source_link)}</span>
                    view source
                </a>` : '';

            // Confidence indicator
            const confidenceHtml = `
                <span class="fact-confidence">
                    <span class="fact-confidence-bar">
                        <span class="fact-confidence-fill ${confLevel}" style="width: ${confidencePercent}%"></span>
                    </span>
                    ${confidencePercent}%
                </span>
            `;

            // Source quote (shown on hover)
            const quoteHtml = fact.source_quote ?
                `<div class="fact-quote">${escapeHtml(fact.source_quote)}</div>` : '';

            return `
                <li class="fact-item ${unconfirmedClass}">
                    <span class="fact-bullet">${fact.category === 'summary' ? 'ðŸ“Š' : 'â€¢'}</span>
                    <span class="fact-content">
                        <span class="fact-text">${escapeHtml(factSentence)}</span>
                        ${sourceLinkHtml}
                        ${confidenceHtml}
                        ${quoteHtml}
                    </span>
                    <div class="fact-actions">
                        ${!fact.confirmed_by_user ? `<button class="fact-action-btn confirm" onclick="confirmFact('${fact.id}'); event.stopPropagation();" title="Confirm">âœ“</button>` : ''}
                        <button class="fact-action-btn delete" onclick="deleteFact('${fact.id}'); event.stopPropagation();" title="Delete">Ã—</button>
                    </div>
                </li>
            `;
        }

        // Get appropriate icon for source link type
        function getSourceIcon(sourceLink) {
            if (!sourceLink) return '';
            if (sourceLink.includes('mail.google.com')) return String.fromCodePoint(0x1F4E7);
            if (sourceLink.includes('calendar.google.com')) return String.fromCodePoint(0x1F4C5);
            if (sourceLink.startsWith('obsidian://')) return String.fromCodePoint(0x1F4DD);
            return String.fromCodePoint(0x1F517);
        }

        // Format a fact key/value pair as a natural sentence
        function formatFactAsSentence(key, value) {
            const keyLower = key.toLowerCase().replace(/_/g, ' ');

            // Common patterns for natural phrasing
            const patterns = {
                'spouse': `Spouse is ${value}`,
                'spouse name': `Spouse is ${value}`,
                'partner': `Partner is ${value}`,
                'kids': `Has kids: ${value}`,
                'children': `Has children: ${value}`,
                'birthday': `Birthday is ${value}`,
                'birth date': `Birthday is ${value}`,
                'company': `Works at ${value}`,
                'employer': `Works at ${value}`,
                'job title': `Works as ${value}`,
                'role': `Role is ${value}`,
                'title': `Title is ${value}`,
                'hometown': `From ${value}`,
                'location': `Located in ${value}`,
                'city': `Lives in ${value}`,
                'email': `Email is ${value}`,
                'phone': `Phone is ${value}`,
                'alma mater': `Studied at ${value}`,
                'school': `Studied at ${value}`,
                'university': `Attended ${value}`,
                'hobby': `Enjoys ${value}`,
                'hobbies': `Enjoys ${value}`,
                'interest': `Interested in ${value}`,
                'interests': `Interested in ${value}`,
                'favorite': `Favorite: ${value}`,
                'pet': `Has a pet: ${value}`,
                'pets': `Has pets: ${value}`,
                'anniversary': `Anniversary is ${value}`,
                // Summary category patterns
                'relationship trajectory': value,
                'key themes': `Key themes: ${value}`,
                'major events': `Major events: ${value}`,
                'communication style': `Communication style: ${value}`,
            };

            // Check for exact or partial matches
            for (const [pattern, template] of Object.entries(patterns)) {
                if (keyLower === pattern || keyLower.includes(pattern)) {
                    return template;
                }
            }

            // Default: capitalize key and use "is" connector
            const capitalizedKey = keyLower.charAt(0).toUpperCase() + keyLower.slice(1);
            return `${capitalizedKey} is ${value}`;
        }

        // Format source attribution text
        function formatSourceAttribution(fact) {
            if (!fact.source_interaction_id && !fact.extracted_at) {
                return '';
            }

            // For now, show extracted date as source indicator
            // Could be enhanced to show actual source type if available
            if (fact.extracted_at) {
                return `(extracted ${formatRelativeDate(fact.extracted_at)})`;
            }

            return '';
        }

        // Format a date as relative text (e.g., "Mar 15" or "2 days ago")
        function formatRelativeDate(dateStr) {
            if (!dateStr) return '';

            const date = new Date(dateStr);
            const now = new Date();
            const diffMs = now - date;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'yesterday';
            if (diffDays < 7) return `${diffDays} days ago`;
            if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;

            // Format as "Mar 15" for older dates
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getDate()}`;
        }

        // Extract facts using LLM
        async function extractFacts() {
            if (!selectedPersonId) return;

            const btn = document.getElementById('extractFactsBtn');
            btn.disabled = true;
            btn.classList.add('extracting');
            btn.innerHTML = '<span>Extracting...</span>';

            try {
                const data = await api(`/people/${selectedPersonId}/facts/extract`, { method: 'POST' });

                if (data.status === 'no_interactions') {
                    alert('No interactions found to extract facts from.');
                } else {
                    // Reload facts to show updated list
                    await loadFacts(selectedPersonId);
                }
            } catch (error) {
                console.error('Failed to extract facts:', error);
                alert('Failed to extract facts. Please try again.');
            } finally {
                btn.disabled = false;
                btn.classList.remove('extracting');
                btn.innerHTML = '<span>Extract Facts</span>';
            }
        }

        // Confirm a fact
        async function confirmFact(factId) {
            if (!selectedPersonId) return;

            try {
                await api(`/people/${selectedPersonId}/facts/${factId}/confirm`, { method: 'POST' });
                await loadFacts(selectedPersonId);
            } catch (error) {
                console.error('Failed to confirm fact:', error);
            }
        }

        // Delete a fact
        async function deleteFact(factId) {
            if (!selectedPersonId) return;

            if (!confirm('Are you sure you want to delete this fact?')) return;

            try {
                await api(`/people/${selectedPersonId}/facts/${factId}`, { method: 'DELETE' });
                await loadFacts(selectedPersonId);
            } catch (error) {
                console.error('Failed to delete fact:', error);
            }
        }

        // Timeline state
        let timelineData = [];
        let timelineFilter = 'all';

        // Graph visualization state
        let graphSimulation = null;
        let graphSvg = null;
        let graphZoom = null;
        let graphWeightRange = null;  // Stores min/max/range for edge filtering
        let graphLinks = null;        // Stores link data for CURRENT (filtered) view
        let graphNodes = null;        // Stores node data for CURRENT (filtered) view
        let graphCenterId = null;     // Stores center node ID for edge filtering
        let graphNodesAll = null;     // Stores ORIGINAL unfiltered node data
        let graphLinksAll = null;     // Stores ORIGINAL unfiltered link data
        let graphContainer = null;    // Stores container element for rebuilding
        let showLabelsEnabled = true;
        let currentZoomScale = 1;
        let isRenderingGraph = false; // Guard against infinite render loops
        let filterDebounceTimer = null; // Debounce timer for filter changes

        // Preserved filter state (for node-to-node navigation)
        let preservedEdgeStrength = null;
        let preservedDegreeFilter = null;
        let preservedSourceFilter = null;

        // Source filter functions
        function toggleSourceFilter() {
            const options = document.getElementById('sourceFilterOptions');
            options.classList.toggle('visible');

            // Close on outside click
            if (options.classList.contains('visible')) {
                setTimeout(() => {
                    document.addEventListener('click', closeSourceFilterOnOutsideClick);
                }, 0);
            }
        }

        function closeSourceFilterOnOutsideClick(e) {
            const dropdown = document.getElementById('sourceFilterDropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                document.getElementById('sourceFilterOptions').classList.remove('visible');
                document.removeEventListener('click', closeSourceFilterOnOutsideClick);
            }
        }

        function getSelectedSources() {
            const checkboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]');
            const selected = [];
            checkboxes.forEach(cb => {
                if (cb.checked) selected.push(cb.value);
            });
            return selected;
        }

        function updateSourceFilter() {
            const selected = getSelectedSources();
            const label = document.getElementById('sourceFilterLabel');

            if (selected.length === 6) {
                label.textContent = 'All Sources';
            } else if (selected.length === 0) {
                label.textContent = 'None';
            } else if (selected.length <= 2) {
                label.textContent = selected.join(', ');
            } else {
                label.textContent = `${selected.length} sources`;
            }

            // Debounce to avoid rapid rebuilds
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 300);
        }

        function restoreSourceFilter(sources) {
            const checkboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = sources.includes(cb.value);
            });
            updateSourceFilter();
        }

        // Calculate filtered edge weight based on selected sources
        function calculateFilteredWeight(edge, selectedSources) {
            let weight = 0;
            if (selectedSources.includes('calendar')) {
                weight += (edge.shared_events_count || 0) * 3;
            }
            if (selectedSources.includes('email')) {
                weight += (edge.shared_threads_count || 0) * 2;
            }
            if (selectedSources.includes('imessage')) {
                weight += (edge.shared_messages_count || 0) * 2;
            }
            if (selectedSources.includes('whatsapp')) {
                weight += (edge.shared_whatsapp_count || 0) * 2;
            }
            if (selectedSources.includes('slack')) {
                weight += (edge.shared_slack_count || 0);
            }
            if (selectedSources.includes('phone')) {
                weight += (edge.shared_phone_calls_count || 0) * 4;
            }
            if (selectedSources.includes('linkedin') && edge.is_linkedin_connection) {
                weight += 10;
            }
            return weight;
        }

        // Check if edge has any signal from selected sources
        function edgeHasSelectedSource(edge, selectedSources) {
            if (selectedSources.includes('calendar') && (edge.shared_events_count || 0) > 0) return true;
            if (selectedSources.includes('email') && (edge.shared_threads_count || 0) > 0) return true;
            if (selectedSources.includes('imessage') && (edge.shared_messages_count || 0) > 0) return true;
            if (selectedSources.includes('whatsapp') && (edge.shared_whatsapp_count || 0) > 0) return true;
            if (selectedSources.includes('slack') && (edge.shared_slack_count || 0) > 0) return true;
            if (selectedSources.includes('phone') && (edge.shared_phone_calls_count || 0) > 0) return true;
            if (selectedSources.includes('linkedin') && edge.is_linkedin_connection) return true;
            return false;
        }

        // Calculate optimal edge strength threshold to show approximately targetNodeCount nodes
        function calculateOptimalEdgeThreshold(nodes, links, centerId, targetNodeCount = 25) {
            // Get all first-degree edges (connected to center)
            const firstDegreeEdges = links.filter(l => l.source === centerId || l.target === centerId);

            if (firstDegreeEdges.length === 0) return 0;

            // Get weights of first-degree edges
            const weights = firstDegreeEdges.map(l => l.weight);
            const maxWeight = Math.max(1, ...weights);
            const minWeight = Math.min(...weights);
            const weightRange = Math.max(1, maxWeight - minWeight);

            // Count first-degree nodes (excluding center)
            const firstDegreeNodeIds = new Set();
            firstDegreeEdges.forEach(l => {
                if (l.source !== centerId) firstDegreeNodeIds.add(l.source);
                if (l.target !== centerId) firstDegreeNodeIds.add(l.target);
            });
            const totalFirstDegree = firstDegreeNodeIds.size;

            // If we have fewer than target, show all (threshold = 0)
            if (totalFirstDegree <= targetNodeCount) return 0;

            // Binary search for threshold that gives closest to target node count
            let bestThreshold = 0;
            let bestDiff = Infinity;

            for (let percent = 0; percent <= 100; percent += 5) {
                const threshold = minWeight + (weightRange * (percent / 100));

                // Count nodes that would pass this threshold
                const visibleNodes = new Set();
                firstDegreeEdges.forEach(l => {
                    if (l.weight >= threshold) {
                        if (l.source !== centerId) visibleNodes.add(l.source);
                        if (l.target !== centerId) visibleNodes.add(l.target);
                    }
                });

                const nodeCount = visibleNodes.size;
                const diff = Math.abs(nodeCount - targetNodeCount);

                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestThreshold = percent;
                }

                // If we're below target, higher thresholds will only show fewer nodes
                if (nodeCount < targetNodeCount) break;
            }

            return bestThreshold;
        }

        // Load graph visualization using 2-degree network
        async function loadGraph(personId) {
            const container = document.getElementById('graphContainer');
            container.innerHTML = '<div class="loading">Loading graph...</div>';

            try {
                // Use the network endpoint with depth=2 for second-degree connections
                const data = await api(`/network?center_on=${personId}&depth=2`);

                if (!data.nodes || data.nodes.length === 0) {
                    container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”—</div><p>No connections to visualize</p></div>';
                    return;
                }

                // Transform nodes from API format
                const nodes = data.nodes.map(node => ({
                    id: node.id,
                    name: node.name,
                    category: node.category,
                    degree: node.degree,  // 0 = center, 1 = first-degree, 2 = second-degree
                    strength: node.strength,
                    interactionCount: node.interaction_count
                }));

                // Transform edges from API format (include source breakdown for filtering)
                const links = data.edges.map(edge => ({
                    source: edge.source,
                    target: edge.target,
                    weight: edge.weight,
                    type: edge.type,
                    // Source breakdown for multi-source filtering
                    shared_events_count: edge.shared_events_count || 0,
                    shared_threads_count: edge.shared_threads_count || 0,
                    shared_messages_count: edge.shared_messages_count || 0,
                    shared_whatsapp_count: edge.shared_whatsapp_count || 0,
                    shared_slack_count: edge.shared_slack_count || 0,
                    shared_phone_calls_count: edge.shared_phone_calls_count || 0,
                    is_linkedin_connection: edge.is_linkedin_connection || false
                }));

                if (nodes.length === 1) {
                    container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”—</div><p>No connections to visualize</p></div>';
                    return;
                }

                // Store ORIGINAL unfiltered data for filtering
                graphNodesAll = nodes;
                graphLinksAll = links;
                graphContainer = container;
                graphCenterId = personId;

                // Calculate optimal edge strength threshold to show ~25 nodes
                const optimalThreshold = calculateOptimalEdgeThreshold(nodes, links, personId, 25);

                // Set the slider to the optimal value
                const slider = document.getElementById('edgeStrengthSlider');
                if (slider) {
                    slider.value = optimalThreshold;
                    document.getElementById('edgeStrengthValue').textContent = optimalThreshold + '%';
                }

                // Apply filters and render (will compute filtered subset)
                applyGraphFilters();

            } catch (error) {
                console.error('Failed to load graph:', error);
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âš ï¸</div><p>Failed to load graph</p></div>';
            }
        }

        // Get node radius based on degree and strength
        function getNodeRadius(node) {
            // Normalize strength to 0-1 (API returns 0-100 scale)
            const normalizedStrength = (node.strength || 0) / 100;
            const baseRadius = 8 + normalizedStrength * 15;
            // Center node (degree 0) is largest, first-degree normal, second-degree smaller
            if (node.degree === 0) {
                return baseRadius * 1.5;  // Center person is 50% larger
            } else if (node.degree === 2) {
                return baseRadius * 0.7;  // Second-degree is 30% smaller
            }
            return baseRadius;
        }

        // Category colors for nodes
        const categoryColors = {
            self: '#ffffff',      // White (CRM owner)
            family: '#daa520',    // Goldenrod
            work: '#4f46e5',      // Indigo
            personal: '#00bcd4',  // Light blue (cyan)
            unknown: '#6b7280'    // Gray
        };

        // Render D3 force-directed graph with degree-based styling
        function renderGraph(container, nodes, links, centerId) {
            // Stop any existing simulation to prevent memory leaks
            if (graphSimulation) {
                graphSimulation.stop();
                graphSimulation = null;
            }

            container.innerHTML = '';

            const width = container.clientWidth;
            const height = container.clientHeight || 400;
            const centerX = width / 2;
            const centerY = height / 2;

            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            graphSvg = svg;

            // Create group for zoomable content
            const g = svg.append('g');

            // Use pre-calculated weight range from FULL dataset if available (from applyGraphFilters)
            // Otherwise calculate from passed-in links (for backwards compatibility)
            let minWeight, maxWeight, weightRange;
            if (graphWeightRange && graphWeightRange.range > 0) {
                minWeight = graphWeightRange.min;
                maxWeight = graphWeightRange.max;
                weightRange = graphWeightRange.range;
            } else {
                maxWeight = Math.max(1, ...links.map(l => l.weight));
                minWeight = Math.min(...links.map(l => l.weight));
                weightRange = Math.max(1, maxWeight - minWeight);
            }

            // Function to update label visibility based on zoom (edge visibility controlled by slider)
            function updateLabelsForZoom(scale) {
                currentZoomScale = scale;

                // Update label visibility
                if (showLabelsEnabled) {
                    g.selectAll('.graph-node text')
                        .style('display', d => {
                            // Always show center node label
                            if (d.degree === 0) return 'block';
                            // Show 1st degree at scale >= 0.5
                            if (d.degree === 1 && scale >= 0.5) return 'block';
                            // Show 2nd degree only when zoomed in (scale >= 1.2)
                            if (d.degree === 2 && scale >= 1.2) return 'block';
                            return 'none';
                        });
                }
            }

            // Create zoom behavior with label visibility updates
            graphZoom = d3.zoom()
                .scaleExtent([0.05, 4])  // Allow more zoom out to see full network
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                    updateLabelsForZoom(event.transform.k);
                });

            svg.call(graphZoom);

            // Add tooltip div
            const tooltip = d3.select(container)
                .append('div')
                .attr('class', 'graph-tooltip');

            // Create force simulation - standard layout with strong repulsion
            const nodeCount = nodes.length;
            const spreadFactor = Math.max(1.5, Math.sqrt(nodeCount / 15));  // More aggressive spread

            // Initialize node positions - center node fixed at center, others spread around
            nodes.forEach(n => {
                if (n.degree === 0) {
                    // Center node goes exactly at center
                    n.x = centerX;
                    n.y = centerY;
                    n.fx = centerX;  // Fix position so it doesn't move
                    n.fy = centerY;
                } else if (n.x === undefined) {
                    // Other nodes spread around center
                    n.x = centerX + (Math.random() - 0.5) * 200 * spreadFactor;
                    n.y = centerY + (Math.random() - 0.5) * 200 * spreadFactor;
                }
            });

            // Store data globally for the slider and degree filter
            // Only set graphWeightRange if not already set (applyGraphFilters sets it from FULL dataset)
            if (!graphWeightRange || graphWeightRange.range <= 0) {
                graphWeightRange = { min: minWeight, max: maxWeight, range: weightRange };
            }
            graphLinks = links;
            graphNodes = nodes;
            graphCenterId = centerId;

            graphSimulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => {
                        // Much longer distances for clear separation
                        const sourceNode = typeof d.source === 'object' ? d.source : nodes.find(n => n.id === d.source);
                        const targetNode = typeof d.target === 'object' ? d.target : nodes.find(n => n.id === d.target);
                        const minDegree = Math.min(sourceNode?.degree ?? 1, targetNode?.degree ?? 1);

                        // Large base distances scaled by network size
                        if (minDegree === 0) return 180 * spreadFactor;  // Center to 1st degree
                        return 120 * spreadFactor;                        // 1st to 2nd degree
                    })
                    .strength(0.05))  // Very weak links - let repulsion dominate
                .force('charge', d3.forceManyBody()
                    .strength(d => {
                        // Strong repulsion for maximum separation - pulls graph apart to surface subnetworks
                        if (d.degree === 0) return -1800 * spreadFactor;  // Center pushes hard
                        if (d.degree === 1) return -900 * spreadFactor;   // 1st degree spread wide
                        return -450 * spreadFactor;                        // 2nd degree spread
                    })
                    .distanceMax(800 * spreadFactor))
                .force('center', d3.forceCenter(centerX, centerY))
                .force('collision', d3.forceCollide()
                    .radius(d => getNodeRadius(d) + 35 * spreadFactor)  // Large collision radius
                    .strength(1.0))  // Maximum collision strength
                .alphaDecay(0.03)   // Faster decay = settles quicker
                .alphaMin(0.005)    // Higher minimum = stops sooner
                .velocityDecay(0.7) // Higher friction = less jitter
                .stop();  // Don't auto-start - wait until elements are created

            // Stop simulation after it settles (with timeout as backup)
            graphSimulation.on('end', () => {
                console.log('Graph simulation settled');
            });

            // Backup: force stop after 5 seconds
            setTimeout(() => {
                if (graphSimulation) {
                    graphSimulation.alpha(0).stop();
                }
            }, 5000);

            // Helper to check if edge connects to center node
            function isFirstDegreeEdge(d) {
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                return sourceId === centerId || targetId === centerId;
            }

            // Sort links so first-degree edges are rendered last (on top) for easier clicking
            const sortedLinks = [...links].sort((a, b) => {
                const aFirst = isFirstDegreeEdge(a) ? 1 : 0;
                const bFirst = isFirstDegreeEdge(b) ? 1 : 0;
                return aFirst - bFirst;  // First-degree edges come last (rendered on top)
            });

            // Draw links with distinctive first-degree edges
            const link = g.append('g')
                .attr('class', 'graph-links')
                .selectAll('line')
                .data(sortedLinks)
                .join('line')
                .attr('class', d => 'graph-link' + (isFirstDegreeEdge(d) ? ' first-degree' : ''))
                .attr('stroke', d => {
                    if (isFirstDegreeEdge(d)) {
                        // First-degree edges: bright cyan/teal gradient based on weight
                        const normalizedWeight = (d.weight - minWeight) / weightRange;
                        const r = Math.round(0 + normalizedWeight * 50);
                        const g = Math.round(180 + normalizedWeight * 75);
                        const b = Math.round(200 + normalizedWeight * 55);
                        return `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // Second-degree edges: muted blue/gray
                        const normalizedWeight = (d.weight - minWeight) / weightRange;
                        const r = Math.round(60 + normalizedWeight * 20);
                        const g = Math.round(70 + normalizedWeight * 40);
                        const b = Math.round(100 + normalizedWeight * 50);
                        return `rgb(${r}, ${g}, ${b})`;
                    }
                })
                .attr('stroke-width', d => {
                    const normalizedWeight = (d.weight - minWeight) / weightRange;
                    if (isFirstDegreeEdge(d)) {
                        // First-degree: thicker (2 to 5px)
                        return 2 + normalizedWeight * 3;
                    } else {
                        // Second-degree: visible but thinner (1 to 2.5px)
                        return 1 + normalizedWeight * 1.5;
                    }
                })
                .attr('stroke-opacity', d => {
                    const normalizedWeight = (d.weight - minWeight) / weightRange;
                    if (isFirstDegreeEdge(d)) {
                        // First-degree: very visible (0.6 to 0.95)
                        return 0.6 + normalizedWeight * 0.35;
                    } else {
                        // Second-degree: clearly visible (0.35 to 0.7)
                        return 0.35 + normalizedWeight * 0.35;
                    }
                })
                .attr('data-weight', d => d.weight);

            // Add invisible hit areas for easier edge clicking (wider transparent lines)
            // Use same sorted order as visible links
            const linkHitAreas = g.append('g')
                .attr('class', 'graph-link-hit-areas')
                .selectAll('line')
                .data(sortedLinks)
                .join('line')
                .attr('class', 'graph-link-hit')
                .attr('stroke', 'transparent')
                .attr('stroke-width', 15)  // Wide invisible hit area
                .style('cursor', 'pointer')
                .on('click', (event, d) => {
                    event.stopPropagation();
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    showEdgeDetails(sourceId, targetId);
                });

            // Draw nodes
            const node = g.append('g')
                .attr('class', 'graph-nodes')
                .selectAll('g')
                .data(nodes)
                .join('g')
                .attr('class', d => `graph-node degree-${d.degree}` + (d.degree === 0 ? ' selected' : ''))
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', (event, d) => {
                    event.stopPropagation();
                    // Save current filter values before navigating (except edge strength - recalculated per person)
                    const degreeSelect = document.getElementById('degreeFilter');
                    preservedDegreeFilter = degreeSelect ? degreeSelect.value : 'all';
                    preservedSourceFilter = getSelectedSources();
                    // Switch to this person's detail view, stay on Graph tab, and reload their graph
                    selectPerson(d.id, true);
                })
                .on('mouseenter', (event, d) => {
                    const degreeLabel = d.degree === 0 ? 'Center' : (d.degree === 1 ? '1st degree' : '2nd degree');
                    tooltip.html(`
                        <strong>${escapeHtml(d.name)}</strong><br>
                        ${degreeLabel}<br>
                        Category: ${d.category || 'unknown'}<br>
                        Strength: ${Math.round(d.strength || 0)}%<br>
                        Interactions: ${d.interactionCount || 0}
                    `);
                    tooltip.classed('visible', true);
                })
                .on('mousemove', (event) => {
                    tooltip
                        .style('left', (event.offsetX + 10) + 'px')
                        .style('top', (event.offsetY - 10) + 'px');
                })
                .on('mouseleave', () => {
                    tooltip.classed('visible', false);
                });

            // Node circles with degree-based styling
            node.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', d => categoryColors[d.category] || categoryColors.unknown)
                .attr('fill-opacity', d => d.degree === 2 ? 0.7 : 1)
                .attr('stroke', d => {
                    if (d.degree === 0) return 'var(--accent)';
                    if (d.category === 'self') return '#4f46e5';  // Indigo stroke for white self node
                    return 'var(--bg-primary)';
                })
                .attr('stroke-width', d => (d.degree === 0 || d.category === 'self') ? 3 : 2);

            // Node labels - add to ALL nodes, visibility controlled by zoom
            node.append('text')
                .attr('dy', d => getNodeRadius(d) + 12)
                .text(d => truncateName(d.name, d.degree === 0 ? 20 : 12));

            // Apply initial label visibility based on current zoom
            updateLabelsForZoom(currentZoomScale);

            // Update positions on tick
            graphSimulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                linkHitAreas
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Now start the simulation (elements are ready) with lower initial energy
            graphSimulation.alpha(0.5).restart();  // Start calmer to reduce initial jitter

            // Restore or reset the filters
            const slider = document.getElementById('edgeStrengthSlider');
            const degreeFilterEl = document.getElementById('degreeFilter');

            // Use preserved values if available (for node-to-node navigation),
            // otherwise keep current DOM values (for filter-triggered rebuilds),
            // otherwise use defaults (for initial load)
            const currentSliderValue = slider ? parseInt(slider.value) : null;
            const currentDegreeValue = degreeFilterEl ? degreeFilterEl.value : null;
            const currentSourceCheckboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]:checked');
            const currentSourceValue = currentSourceCheckboxes.length > 0 ?
                Array.from(currentSourceCheckboxes).map(cb => cb.value) : null;

            const edgeStrengthValue = preservedEdgeStrength !== null ? preservedEdgeStrength :
                                      (currentSliderValue !== null ? currentSliderValue : 50);
            const degreeFilterValue = preservedDegreeFilter !== null ? preservedDegreeFilter :
                                      (currentDegreeValue !== null ? currentDegreeValue : 'first');
            const sourceFilterValue = preservedSourceFilter !== null ? preservedSourceFilter :
                                      (currentSourceValue !== null ? currentSourceValue :
                                       ['calendar', 'email', 'imessage', 'whatsapp', 'slack', 'linkedin']);

            // Only update DOM if we're using preserved values (navigation scenario)
            // Don't overwrite what the user just set for filter-triggered rebuilds
            if (preservedEdgeStrength !== null && slider) {
                slider.value = edgeStrengthValue;
                document.getElementById('edgeStrengthValue').textContent = edgeStrengthValue + '%';
            }

            if (preservedDegreeFilter !== null && degreeFilterEl) {
                degreeFilterEl.value = degreeFilterValue;
            }

            // Only restore source filter checkboxes if we have preserved values
            if (preservedSourceFilter !== null) {
                const checkboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = sourceFilterValue.includes(cb.value);
                });
                // Update label without triggering filter
                const sourceLabel = document.getElementById('sourceFilterLabel');
                if (sourceLabel) {
                    if (sourceFilterValue.length === 6) {
                        sourceLabel.textContent = 'All Sources';
                    } else if (sourceFilterValue.length === 0) {
                        sourceLabel.textContent = 'None';
                    } else if (sourceFilterValue.length <= 2) {
                        sourceLabel.textContent = sourceFilterValue.join(', ');
                    } else {
                        sourceLabel.textContent = `${sourceFilterValue.length} sources`;
                    }
                }
            }

            // Clear preserved values after using them
            preservedEdgeStrength = null;
            preservedDegreeFilter = null;
            preservedSourceFilter = null;

            // Drag functions - gentler reanimation
            function dragstarted(event, d) {
                if (!event.active) graphSimulation.alphaTarget(0.1).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) graphSimulation.alphaTarget(0);
                // Keep node fixed where user dropped it
                // d.fx = null;
                // d.fy = null;
            }

            // Add legend with degree explanations
            const legend = d3.select(container)
                .append('div')
                .attr('class', 'graph-legend');

            legend.html(`
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: var(--accent); border: 2px solid var(--accent);"></div>
                    <span>Center (Selected)</span>
                </div>
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${categoryColors.work};"></div>
                    <span>1st Degree</span>
                </div>
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${categoryColors.unknown}; opacity: 0.6;"></div>
                    <span>2nd Degree</span>
                </div>
            `);
        }

        // Reset graph zoom
        function resetGraphZoom() {
            if (graphSvg && graphZoom) {
                graphSvg.transition()
                    .duration(300)
                    .call(graphZoom.transform, d3.zoomIdentity);
            }
        }

        // Edge panel state
        let edgePanelData = { personAId: null, personBId: null };
        let selectedEdgeKey = null;  // Track which edge is selected

        // Show edge details panel
        async function showEdgeDetails(sourceId, targetId) {
            const panel = document.getElementById('edgePanel');

            // Clear previous selection and highlight new one
            if (graphSvg) {
                graphSvg.selectAll('.graph-link').classed('selected', false);
                // Find and highlight the clicked edge
                graphSvg.selectAll('.graph-link').each(function(d) {
                    const dSourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const dTargetId = typeof d.target === 'object' ? d.target.id : d.target;
                    if ((dSourceId === sourceId && dTargetId === targetId) ||
                        (dSourceId === targetId && dTargetId === sourceId)) {
                        d3.select(this).classed('selected', true);
                    }
                });
            }
            selectedEdgeKey = `${sourceId}:${targetId}`;

            try {
                const data = await api(`/relationship/${sourceId}/${targetId}`);
                edgePanelData = { personAId: data.person_a_id, personBId: data.person_b_id };

                // Update panel content
                document.getElementById('edgePanelPersonA').textContent = data.person_a_name;
                document.getElementById('edgePanelPersonB').textContent = data.person_b_name;
                // Backend returns normalized 0-100 weight
                document.getElementById('edgePanelWeight').textContent = (data.weight || 0) + '%';

                // Source breakdown
                document.getElementById('edgePanelEvents').textContent = data.shared_events_count || 0;
                document.getElementById('edgePanelThreads').textContent = data.shared_threads_count || 0;
                document.getElementById('edgePanelMessages').textContent = data.shared_messages_count || 0;
                document.getElementById('edgePanelWhatsapp').textContent = data.shared_whatsapp_count || 0;
                document.getElementById('edgePanelSlack').textContent = data.shared_slack_count || 0;
                document.getElementById('edgePanelPhone').textContent = data.shared_phone_calls_count || 0;
                document.getElementById('edgePanelLinkedin').textContent = data.is_linkedin_connection ? 'âœ“ Connected' : 'â€”';

                // Format dates
                const formatDate = (isoStr) => {
                    if (!isoStr) return 'â€”';
                    const date = new Date(isoStr);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                };
                document.getElementById('edgePanelFirstSeen').textContent = formatDate(data.first_seen_together);
                document.getElementById('edgePanelLastSeen').textContent = formatDate(data.last_seen_together);

                // Shared contexts
                const contextsContainer = document.getElementById('edgePanelContexts');
                const tagsContainer = document.getElementById('edgePanelContextTags');
                if (data.shared_contexts && data.shared_contexts.length > 0) {
                    contextsContainer.style.display = 'block';
                    tagsContainer.innerHTML = data.shared_contexts.map(ctx =>
                        `<span class="edge-panel-context-tag">${escapeHtml(ctx)}</span>`
                    ).join('');
                } else {
                    contextsContainer.style.display = 'none';
                }

                panel.classList.add('visible');
            } catch (error) {
                console.error('Failed to load edge details:', error);
            }
        }

        // Close edge panel
        function closeEdgePanel() {
            document.getElementById('edgePanel').classList.remove('visible');
            // Deselect edge
            if (graphSvg) {
                graphSvg.selectAll('.graph-link').classed('selected', false);
            }
            selectedEdgeKey = null;
        }

        // Navigate to person from edge panel
        function navigateToEdgePerson(which) {
            const personId = which === 'a' ? edgePanelData.personAId : edgePanelData.personBId;
            if (personId) {
                // Save current filter values (except edge strength - recalculated per person)
                const degreeSelect = document.getElementById('degreeFilter');
                preservedDegreeFilter = degreeSelect ? degreeSelect.value : 'all';
                preservedSourceFilter = getSelectedSources();

                closeEdgePanel();
                selectPerson(personId, true);
            }
        }

        // Toggle graph labels
        function toggleGraphLabels() {
            showLabelsEnabled = document.getElementById('showLabels').checked;
            if (graphSvg) {
                if (!showLabelsEnabled) {
                    // Hide all labels
                    graphSvg.selectAll('.graph-node text')
                        .style('display', 'none');
                } else {
                    // Re-apply zoom-based visibility
                    graphSvg.selectAll('.graph-node text')
                        .style('display', d => {
                            if (d.degree === 0) return 'block';
                            if (d.degree === 1 && currentZoomScale >= 0.5) return 'block';
                            if (d.degree === 2 && currentZoomScale >= 1.2) return 'block';
                            return 'none';
                        });
                }
            }
        }

        // Apply filters and REBUILD graph with only visible nodes for compact layouts
        function applyGraphFilters() {
            if (!graphNodesAll || !graphLinksAll || !graphContainer) return;

            // Prevent infinite loops from events during render
            if (isRenderingGraph) return;
            isRenderingGraph = true;

            try {
                // Get current filter values
                const slider = document.getElementById('edgeStrengthSlider');
                const degreeSelect = document.getElementById('degreeFilter');
                const thresholdPercent = slider ? parseInt(slider.value) : 15;
                const showOnlyFirstDegree = degreeSelect ? (degreeSelect.value === 'first') : false;
                const selectedSources = getSelectedSources();

                // Calculate weight threshold from the FULL dataset
                const allWeights = graphLinksAll.map(l => l.weight);
                const maxWeight = Math.max(1, ...allWeights);
                const minWeight = allWeights.length > 0 ? Math.min(...allWeights) : 0;
                const weightRange = Math.max(1, maxWeight - minWeight);
                const threshold = minWeight + (weightRange * (thresholdPercent / 100));

                // Build node lookup by ID from ORIGINAL data
                const nodeById = {};
                graphNodesAll.forEach(n => { nodeById[n.id] = n; });

                // Step 1: Determine which first-degree nodes pass the edge strength and source filter
                const visibleNodeIds = new Set();
                visibleNodeIds.add(graphCenterId); // Center node always visible

                graphLinksAll.forEach(linkData => {
                    if (!linkData) return;

                    const sourceId = linkData.source;
                    const targetId = linkData.target;
                    const isFirstDegree = sourceId === graphCenterId || targetId === graphCenterId;

                    // Check if edge has signal from any selected source
                    const hasSelectedSource = edgeHasSelectedSource(linkData, selectedSources);

                    // First-degree edges with sufficient weight make the OTHER node visible
                    // Use linkData.weight (normalized 0-100) for threshold comparison
                    if (isFirstDegree && hasSelectedSource && linkData.weight >= threshold) {
                        visibleNodeIds.add(sourceId);
                        visibleNodeIds.add(targetId);
                    }
                });

                // Step 2: If showing 2nd degree too, add second-degree nodes connected to visible first-degree
                if (!showOnlyFirstDegree) {
                    const firstDegreeIds = new Set(visibleNodeIds);

                    graphLinksAll.forEach(linkData => {
                        if (!linkData) return;

                        const sourceId = linkData.source;
                        const targetId = linkData.target;
                        const sourceNode = nodeById[sourceId];
                        const targetNode = nodeById[targetId];

                        // Edge must pass source filter
                        const hasSelectedSource = edgeHasSelectedSource(linkData, selectedSources);
                        if (!hasSelectedSource) return;

                        // If one end is a visible first-degree node and other is second-degree, add it
                        if (firstDegreeIds.has(sourceId) && targetNode && targetNode.degree === 2) {
                            visibleNodeIds.add(targetId);
                        }
                        if (firstDegreeIds.has(targetId) && sourceNode && sourceNode.degree === 2) {
                            visibleNodeIds.add(sourceId);
                        }
                    });
                }

                // Step 3: Create filtered node and link arrays
                const filteredNodes = graphNodesAll
                    .filter(n => visibleNodeIds.has(n.id))
                    .map(n => ({...n, x: undefined, y: undefined, fx: undefined, fy: undefined})); // Reset positions

                const filteredLinks = graphLinksAll.filter(l => {
                    const sourceId = l.source;
                    const targetId = l.target;
                    const bothVisible = visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
                    const hasSelectedSource = edgeHasSelectedSource(l, selectedSources);
                    return bothVisible && hasSelectedSource;
                }).map(l => ({...l})); // Clone to avoid mutating original

                // Store filtered data as current view
                graphNodes = filteredNodes;
                graphLinks = filteredLinks;
                graphWeightRange = { min: minWeight, max: maxWeight, range: weightRange };

                // Check if we have anything to show
                if (filteredNodes.length <= 1) {
                    if (graphSimulation) {
                        graphSimulation.stop();
                    }
                    graphContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”—</div><p>No connections match current filters</p></div>';
                    graphSvg = null;
                    graphSimulation = null;
                    return;
                }

                // Rebuild the graph with only filtered data
                renderGraph(graphContainer, filteredNodes, filteredLinks, graphCenterId);
            } finally {
                isRenderingGraph = false;
            }
        }

        // Update edge visibility - wrapper that calls unified filter
        function updateEdgeVisibility(thresholdPercent) {
            document.getElementById('edgeStrengthValue').textContent = thresholdPercent + '%';
            // Debounce filter application to avoid rebuilding graph while dragging slider
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 500);
        }

        // Update degree filter - wrapper that calls unified filter
        function updateDegreeFilter(value) {
            // Debounce to avoid rapid rebuilds
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 300);
        }

        // Helper to truncate name
        function truncateName(name, maxLen) {
            if (!name) return '';
            if (name.length <= maxLen) return name;
            return name.substring(0, maxLen - 1) + 'â€¦';
        }

        // Switch tab
        async function switchTab(tabName, skipUrlUpdate = false) {
            // Update tab UI
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

            // Show/hide content
            document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
            const tabContent = document.getElementById(`tab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            tabContent.style.display = tabName === 'graph' ? 'flex' : 'block';

            // Toggle graph mode (compact header)
            const detailContent = document.getElementById('detailContent');
            if (tabName === 'graph') {
                detailContent.classList.add('graph-mode');
            } else {
                detailContent.classList.remove('graph-mode');
            }

            // Load data if needed
            if (selectedPersonId) {
                if (tabName === 'timeline') {
                    await loadTimeline(selectedPersonId);
                } else if (tabName === 'graph') {
                    await loadGraph(selectedPersonId);
                }

                // Update URL (unless called from popstate or initial load)
                if (!skipUrlUpdate) {
                    updateUrl(selectedPersonId, tabName);
                }
            }
        }

        // Toggle source entities
        function toggleSourceEntities() {
            const list = document.getElementById('sourceEntitiesList');
            const toggle = document.getElementById('sourceEntitiesToggle');

            if (list.classList.contains('expanded')) {
                list.classList.remove('expanded');
                toggle.textContent = 'â–¶';
            } else {
                list.classList.add('expanded');
                toggle.textContent = 'â–¼';
            }
        }

        // Save notes
        async function saveNotes() {
            if (!selectedPersonId) return;

            const notes = document.getElementById('notesArea').value;

            try {
                await api(`/people/${selectedPersonId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ notes })
                });
            } catch (error) {
                console.error('Failed to save notes:', error);
            }
        }

        // Set filter
        function setFilter(filter) {
            currentFilter = filter;

            // Update UI
            document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
            document.querySelector(`[data-filter="${filter}"]`).classList.add('active');

            loadPeople();
        }

        // Handle search
        let searchTimeout;
        function handleSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchQuery = document.getElementById('searchInput').value;
                loadPeople();
            }, 300);
        }

        // Utility functions
        function getInitials(name) {
            if (!name) return '?';
            const parts = name.split(' ').filter(p => p.length > 0);
            if (parts.length === 0) return '?';
            if (parts.length === 1) return parts[0][0].toUpperCase();
            return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
        }

        // Avatar colors by category
        const avatarColors = {
            self: { bg: '#ffffff', text: '#1a1a2e' },           // White with dark text
            family: { bg: '#daa520', text: '#1a1a2e' },         // Goldenrod
            work: { bg: '#4f46e5', text: '#ffffff' },           // Indigo
            personal: { bg: '#00bcd4', text: '#1a1a2e' },       // Light blue (cyan)
        };

        function getAvatarStyle(category) {
            const colors = avatarColors[category] || avatarColors.personal;
            return `background: ${colors.bg}; color: ${colors.text};`;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDate(dateStr) {
            if (!dateStr) return 'Never';
            const date = new Date(dateStr);
            const now = new Date();
            const diff = now - date;

            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
            if (diff < 86400000 && date.toDateString() === now.toDateString()) {
                return Math.floor(diff / 3600000) + 'h ago';
            }

            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'Yesterday';
            }

            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
            });
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
